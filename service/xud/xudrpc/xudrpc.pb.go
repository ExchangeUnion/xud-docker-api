// Copyright 2018 The Exchange Union Developers

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.21.0
// 	protoc        v3.13.0
// source: xudrpc.proto

package xudrpc

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type OrderSide int32

const (
	OrderSide_BUY  OrderSide = 0
	OrderSide_SELL OrderSide = 1
	OrderSide_BOTH OrderSide = 2
)

// Enum value maps for OrderSide.
var (
	OrderSide_name = map[int32]string{
		0: "BUY",
		1: "SELL",
		2: "BOTH",
	}
	OrderSide_value = map[string]int32{
		"BUY":  0,
		"SELL": 1,
		"BOTH": 2,
	}
)

func (x OrderSide) Enum() *OrderSide {
	p := new(OrderSide)
	*p = x
	return p
}

func (x OrderSide) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderSide) Descriptor() protoreflect.EnumDescriptor {
	return file_xudrpc_proto_enumTypes[0].Descriptor()
}

func (OrderSide) Type() protoreflect.EnumType {
	return &file_xudrpc_proto_enumTypes[0]
}

func (x OrderSide) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderSide.Descriptor instead.
func (OrderSide) EnumDescriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{0}
}

type Role int32

const (
	Role_TAKER    Role = 0
	Role_MAKER    Role = 1
	Role_INTERNAL Role = 2
)

// Enum value maps for Role.
var (
	Role_name = map[int32]string{
		0: "TAKER",
		1: "MAKER",
		2: "INTERNAL",
	}
	Role_value = map[string]int32{
		"TAKER":    0,
		"MAKER":    1,
		"INTERNAL": 2,
	}
)

func (x Role) Enum() *Role {
	p := new(Role)
	*p = x
	return p
}

func (x Role) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Role) Descriptor() protoreflect.EnumDescriptor {
	return file_xudrpc_proto_enumTypes[1].Descriptor()
}

func (Role) Type() protoreflect.EnumType {
	return &file_xudrpc_proto_enumTypes[1]
}

func (x Role) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Role.Descriptor instead.
func (Role) EnumDescriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{1}
}

type Currency_SwapClient int32

const (
	Currency_LND     Currency_SwapClient = 0
	Currency_CONNEXT Currency_SwapClient = 2
)

// Enum value maps for Currency_SwapClient.
var (
	Currency_SwapClient_name = map[int32]string{
		0: "LND",
		2: "CONNEXT",
	}
	Currency_SwapClient_value = map[string]int32{
		"LND":     0,
		"CONNEXT": 2,
	}
)

func (x Currency_SwapClient) Enum() *Currency_SwapClient {
	p := new(Currency_SwapClient)
	*p = x
	return p
}

func (x Currency_SwapClient) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Currency_SwapClient) Descriptor() protoreflect.EnumDescriptor {
	return file_xudrpc_proto_enumTypes[2].Descriptor()
}

func (Currency_SwapClient) Type() protoreflect.EnumType {
	return &file_xudrpc_proto_enumTypes[2]
}

func (x Currency_SwapClient) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Currency_SwapClient.Descriptor instead.
func (Currency_SwapClient) EnumDescriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{14, 0}
}

type ListOrdersRequest_Owner int32

const (
	ListOrdersRequest_BOTH ListOrdersRequest_Owner = 0
	ListOrdersRequest_OWN  ListOrdersRequest_Owner = 1
	ListOrdersRequest_PEER ListOrdersRequest_Owner = 2
)

// Enum value maps for ListOrdersRequest_Owner.
var (
	ListOrdersRequest_Owner_name = map[int32]string{
		0: "BOTH",
		1: "OWN",
		2: "PEER",
	}
	ListOrdersRequest_Owner_value = map[string]int32{
		"BOTH": 0,
		"OWN":  1,
		"PEER": 2,
	}
)

func (x ListOrdersRequest_Owner) Enum() *ListOrdersRequest_Owner {
	p := new(ListOrdersRequest_Owner)
	*p = x
	return p
}

func (x ListOrdersRequest_Owner) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ListOrdersRequest_Owner) Descriptor() protoreflect.EnumDescriptor {
	return file_xudrpc_proto_enumTypes[3].Descriptor()
}

func (ListOrdersRequest_Owner) Type() protoreflect.EnumType {
	return &file_xudrpc_proto_enumTypes[3]
}

func (x ListOrdersRequest_Owner) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ListOrdersRequest_Owner.Descriptor instead.
func (ListOrdersRequest_Owner) EnumDescriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{28, 0}
}

type AddCurrencyResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *AddCurrencyResponse) Reset() {
	*x = AddCurrencyResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddCurrencyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddCurrencyResponse) ProtoMessage() {}

func (x *AddCurrencyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddCurrencyResponse.ProtoReflect.Descriptor instead.
func (*AddCurrencyResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{0}
}

type AddPairRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The base currency that is bought and sold for this trading pair.
	BaseCurrency string `protobuf:"bytes,1,opt,name=base_currency,proto3" json:"base_currency,omitempty"`
	// The currency used to quote a price for the base currency.
	QuoteCurrency string `protobuf:"bytes,2,opt,name=quote_currency,proto3" json:"quote_currency,omitempty"`
}

func (x *AddPairRequest) Reset() {
	*x = AddPairRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddPairRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddPairRequest) ProtoMessage() {}

func (x *AddPairRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddPairRequest.ProtoReflect.Descriptor instead.
func (*AddPairRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{1}
}

func (x *AddPairRequest) GetBaseCurrency() string {
	if x != nil {
		return x.BaseCurrency
	}
	return ""
}

func (x *AddPairRequest) GetQuoteCurrency() string {
	if x != nil {
		return x.QuoteCurrency
	}
	return ""
}

type AddPairResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *AddPairResponse) Reset() {
	*x = AddPairResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddPairResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddPairResponse) ProtoMessage() {}

func (x *AddPairResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddPairResponse.ProtoReflect.Descriptor instead.
func (*AddPairResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{2}
}

type Balance struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total balance denominated in satoshis.
	TotalBalance uint64 `protobuf:"varint,1,opt,name=total_balance,proto3" json:"total_balance,omitempty"`
	// Sum of confirmed channel balances denominated in satoshis.
	ChannelBalance uint64 `protobuf:"varint,2,opt,name=channel_balance,proto3" json:"channel_balance,omitempty"`
	// Sum of pending channel balances denominated in satoshis.
	PendingChannelBalance uint64 `protobuf:"varint,3,opt,name=pending_channel_balance,proto3" json:"pending_channel_balance,omitempty"`
	// Sum of inactive channel balances denominated in satoshis.
	InactiveChannelBalance uint64 `protobuf:"varint,4,opt,name=inactive_channel_balance,proto3" json:"inactive_channel_balance,omitempty"`
	// Confirmed wallet balance in satoshis.
	WalletBalance uint64 `protobuf:"varint,5,opt,name=wallet_balance,proto3" json:"wallet_balance,omitempty"`
	// Unconfirmed wallet balance in satoshis.
	UnconfirmedWalletBalance uint64 `protobuf:"varint,6,opt,name=unconfirmed_wallet_balance,proto3" json:"unconfirmed_wallet_balance,omitempty"`
}

func (x *Balance) Reset() {
	*x = Balance{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Balance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Balance) ProtoMessage() {}

func (x *Balance) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Balance.ProtoReflect.Descriptor instead.
func (*Balance) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{3}
}

func (x *Balance) GetTotalBalance() uint64 {
	if x != nil {
		return x.TotalBalance
	}
	return 0
}

func (x *Balance) GetChannelBalance() uint64 {
	if x != nil {
		return x.ChannelBalance
	}
	return 0
}

func (x *Balance) GetPendingChannelBalance() uint64 {
	if x != nil {
		return x.PendingChannelBalance
	}
	return 0
}

func (x *Balance) GetInactiveChannelBalance() uint64 {
	if x != nil {
		return x.InactiveChannelBalance
	}
	return 0
}

func (x *Balance) GetWalletBalance() uint64 {
	if x != nil {
		return x.WalletBalance
	}
	return 0
}

func (x *Balance) GetUnconfirmedWalletBalance() uint64 {
	if x != nil {
		return x.UnconfirmedWalletBalance
	}
	return 0
}

type BanRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node pub key or alias of the node to ban.
	NodeIdentifier string `protobuf:"bytes,1,opt,name=node_identifier,proto3" json:"node_identifier,omitempty"`
}

func (x *BanRequest) Reset() {
	*x = BanRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BanRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BanRequest) ProtoMessage() {}

func (x *BanRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BanRequest.ProtoReflect.Descriptor instead.
func (*BanRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{4}
}

func (x *BanRequest) GetNodeIdentifier() string {
	if x != nil {
		return x.NodeIdentifier
	}
	return ""
}

type BanResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *BanResponse) Reset() {
	*x = BanResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BanResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BanResponse) ProtoMessage() {}

func (x *BanResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BanResponse.ProtoReflect.Descriptor instead.
func (*BanResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{5}
}

type Chain struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The blockchain the swap client is on (eg bitcoin, litecoin)
	Chain string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	// The network the swap client is on (eg regtest, testnet, mainnet)
	Network string `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
}

func (x *Chain) Reset() {
	*x = Chain{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Chain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Chain) ProtoMessage() {}

func (x *Chain) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Chain.ProtoReflect.Descriptor instead.
func (*Chain) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{6}
}

func (x *Chain) GetChain() string {
	if x != nil {
		return x.Chain
	}
	return ""
}

func (x *Chain) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

type Channels struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The number of active/online channels for this lnd instance that can be used for swaps.
	Active uint32 `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	// The number of inactive/offline channels for this lnd instance.
	Inactive uint32 `protobuf:"varint,2,opt,name=inactive,proto3" json:"inactive,omitempty"`
	// The number of channels that are pending on-chain confirmation before they can be used.
	Pending uint32 `protobuf:"varint,3,opt,name=pending,proto3" json:"pending,omitempty"`
	// The number of channels that have been closed.
	Closed uint32 `protobuf:"varint,4,opt,name=closed,proto3" json:"closed,omitempty"`
}

func (x *Channels) Reset() {
	*x = Channels{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Channels) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Channels) ProtoMessage() {}

func (x *Channels) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Channels.ProtoReflect.Descriptor instead.
func (*Channels) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{7}
}

func (x *Channels) GetActive() uint32 {
	if x != nil {
		return x.Active
	}
	return 0
}

func (x *Channels) GetInactive() uint32 {
	if x != nil {
		return x.Inactive
	}
	return 0
}

func (x *Channels) GetPending() uint32 {
	if x != nil {
		return x.Pending
	}
	return 0
}

func (x *Channels) GetClosed() uint32 {
	if x != nil {
		return x.Closed
	}
	return 0
}

type CloseChannelRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node pub key or alias of the peer with which to close any channels with.
	NodeIdentifier string `protobuf:"bytes,1,opt,name=node_identifier,proto3" json:"node_identifier,omitempty"`
	// The ticker symbol of the currency of the channel to close.
	Currency string `protobuf:"bytes,2,opt,name=currency,proto3" json:"currency,omitempty"`
	// Whether to force close the channel in case the peer is offline or unresponsive.
	Force bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	// The on-chain address to send funds extracted from the channel. If unspecified,
	// the funds return to the default wallet for the client closing the channel.
	Destination string `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	// For Connext only - the amount to extract from the channel. If 0 or unspecified,
	// the entire off-chain balance for the specified currency will be extracted.
	Amount uint64 `protobuf:"varint,5,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *CloseChannelRequest) Reset() {
	*x = CloseChannelRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CloseChannelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseChannelRequest) ProtoMessage() {}

func (x *CloseChannelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseChannelRequest.ProtoReflect.Descriptor instead.
func (*CloseChannelRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{8}
}

func (x *CloseChannelRequest) GetNodeIdentifier() string {
	if x != nil {
		return x.NodeIdentifier
	}
	return ""
}

func (x *CloseChannelRequest) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *CloseChannelRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

func (x *CloseChannelRequest) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *CloseChannelRequest) GetAmount() uint64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

type CloseChannelResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The id of the transaction per channel close.
	TransactionIds []string `protobuf:"bytes,1,rep,name=transaction_ids,proto3" json:"transaction_ids,omitempty"`
}

func (x *CloseChannelResponse) Reset() {
	*x = CloseChannelResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CloseChannelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseChannelResponse) ProtoMessage() {}

func (x *CloseChannelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseChannelResponse.ProtoReflect.Descriptor instead.
func (*CloseChannelResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{9}
}

func (x *CloseChannelResponse) GetTransactionIds() []string {
	if x != nil {
		return x.TransactionIds
	}
	return nil
}

type ConnectRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The uri of the node to connect to in "[nodePubKey]@[host]:[port]" format.
	NodeUri string `protobuf:"bytes,1,opt,name=node_uri,proto3" json:"node_uri,omitempty"`
}

func (x *ConnectRequest) Reset() {
	*x = ConnectRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectRequest) ProtoMessage() {}

func (x *ConnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{10}
}

func (x *ConnectRequest) GetNodeUri() string {
	if x != nil {
		return x.NodeUri
	}
	return ""
}

type ConnectResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ConnectResponse) Reset() {
	*x = ConnectResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConnectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectResponse) ProtoMessage() {}

func (x *ConnectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectResponse.ProtoReflect.Descriptor instead.
func (*ConnectResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{11}
}

type CreateNodeRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The password in utf-8 with which to encrypt the new xud node key as well
	// as any uninitialized underlying wallets.
	Password string `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *CreateNodeRequest) Reset() {
	*x = CreateNodeRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateNodeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateNodeRequest) ProtoMessage() {}

func (x *CreateNodeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateNodeRequest.ProtoReflect.Descriptor instead.
func (*CreateNodeRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{12}
}

func (x *CreateNodeRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type CreateNodeResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The 24 word mnemonic to recover the xud identity key and underlying wallets
	SeedMnemonic []string `protobuf:"bytes,1,rep,name=seed_mnemonic,json=seedMnemonic,proto3" json:"seed_mnemonic,omitempty"`
	// The list of lnd clients that were initialized.
	InitializedLnds []string `protobuf:"bytes,2,rep,name=initialized_lnds,json=initializedLnds,proto3" json:"initialized_lnds,omitempty"`
}

func (x *CreateNodeResponse) Reset() {
	*x = CreateNodeResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateNodeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateNodeResponse) ProtoMessage() {}

func (x *CreateNodeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateNodeResponse.ProtoReflect.Descriptor instead.
func (*CreateNodeResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{13}
}

func (x *CreateNodeResponse) GetSeedMnemonic() []string {
	if x != nil {
		return x.SeedMnemonic
	}
	return nil
}

func (x *CreateNodeResponse) GetInitializedLnds() []string {
	if x != nil {
		return x.InitializedLnds
	}
	return nil
}

type Currency struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	// The payment channel network client to use for executing swaps.
	SwapClient Currency_SwapClient `protobuf:"varint,2,opt,name=swap_client,proto3,enum=xudrpc.Currency_SwapClient" json:"swap_client,omitempty"`
	// The contract address for layered tokens such as ERC20.
	TokenAddress string `protobuf:"bytes,3,opt,name=token_address,proto3" json:"token_address,omitempty"`
	// The number of places to the right of the decimal point of the smallest subunit of the currency.
	// For example, BTC, LTC, and others where the smallest subunits (satoshis) are 0.00000001 full
	// units (bitcoins) have 8 decimal places. ETH has 18. This can be thought of as the base 10
	// exponent of the smallest subunit expressed as a positive integer. A default value of 8 is
	// used if unspecified.
	DecimalPlaces uint32 `protobuf:"varint,4,opt,name=decimal_places,proto3" json:"decimal_places,omitempty"`
}

func (x *Currency) Reset() {
	*x = Currency{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Currency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Currency) ProtoMessage() {}

func (x *Currency) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Currency.ProtoReflect.Descriptor instead.
func (*Currency) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{14}
}

func (x *Currency) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *Currency) GetSwapClient() Currency_SwapClient {
	if x != nil {
		return x.SwapClient
	}
	return Currency_LND
}

func (x *Currency) GetTokenAddress() string {
	if x != nil {
		return x.TokenAddress
	}
	return ""
}

func (x *Currency) GetDecimalPlaces() uint32 {
	if x != nil {
		return x.DecimalPlaces
	}
	return 0
}

type DepositRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ticker symbol of the currency to deposit.
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (x *DepositRequest) Reset() {
	*x = DepositRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DepositRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositRequest) ProtoMessage() {}

func (x *DepositRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositRequest.ProtoReflect.Descriptor instead.
func (*DepositRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{15}
}

func (x *DepositRequest) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

type DepositResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The address to use to deposit funds.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (x *DepositResponse) Reset() {
	*x = DepositResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DepositResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositResponse) ProtoMessage() {}

func (x *DepositResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositResponse.ProtoReflect.Descriptor instead.
func (*DepositResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{16}
}

func (x *DepositResponse) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type DiscoverNodesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node pub key or alias of the peer to discover nodes from.
	NodeIdentifier string `protobuf:"bytes,1,opt,name=node_identifier,proto3" json:"node_identifier,omitempty"`
}

func (x *DiscoverNodesRequest) Reset() {
	*x = DiscoverNodesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DiscoverNodesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoverNodesRequest) ProtoMessage() {}

func (x *DiscoverNodesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoverNodesRequest.ProtoReflect.Descriptor instead.
func (*DiscoverNodesRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{17}
}

func (x *DiscoverNodesRequest) GetNodeIdentifier() string {
	if x != nil {
		return x.NodeIdentifier
	}
	return ""
}

type DiscoverNodesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NumNodes uint32 `protobuf:"varint,1,opt,name=num_nodes,proto3" json:"num_nodes,omitempty"`
}

func (x *DiscoverNodesResponse) Reset() {
	*x = DiscoverNodesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DiscoverNodesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoverNodesResponse) ProtoMessage() {}

func (x *DiscoverNodesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoverNodesResponse.ProtoReflect.Descriptor instead.
func (*DiscoverNodesResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{18}
}

func (x *DiscoverNodesResponse) GetNumNodes() uint32 {
	if x != nil {
		return x.NumNodes
	}
	return 0
}

type ExecuteSwapRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The order id of the maker order.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The trading pair of the swap orders.
	PairId string `protobuf:"bytes,2,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The node pub key of the peer which owns the maker order. This is optional but helps locate the order more quickly.
	PeerPubKey string `protobuf:"bytes,3,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	// The quantity to swap denominated in satoshis. The whole order will be swapped if unspecified.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
}

func (x *ExecuteSwapRequest) Reset() {
	*x = ExecuteSwapRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecuteSwapRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteSwapRequest) ProtoMessage() {}

func (x *ExecuteSwapRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteSwapRequest.ProtoReflect.Descriptor instead.
func (*ExecuteSwapRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{19}
}

func (x *ExecuteSwapRequest) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *ExecuteSwapRequest) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *ExecuteSwapRequest) GetPeerPubKey() string {
	if x != nil {
		return x.PeerPubKey
	}
	return ""
}

func (x *ExecuteSwapRequest) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type GetBalanceRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ticker symbol of the currency to query for, if unspecified then balances for all supported
	// currencies are queried.
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (x *GetBalanceRequest) Reset() {
	*x = GetBalanceRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetBalanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBalanceRequest) ProtoMessage() {}

func (x *GetBalanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBalanceRequest.ProtoReflect.Descriptor instead.
func (*GetBalanceRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{20}
}

func (x *GetBalanceRequest) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

type GetBalanceResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map between currency ticker symbols and their balances.
	Balances map[string]*Balance `protobuf:"bytes,1,rep,name=balances,json=orders,proto3" json:"balances,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *GetBalanceResponse) Reset() {
	*x = GetBalanceResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetBalanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBalanceResponse) ProtoMessage() {}

func (x *GetBalanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBalanceResponse.ProtoReflect.Descriptor instead.
func (*GetBalanceResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{21}
}

func (x *GetBalanceResponse) GetBalances() map[string]*Balance {
	if x != nil {
		return x.Balances
	}
	return nil
}

type GetInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *GetInfoRequest) Reset() {
	*x = GetInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetInfoRequest) ProtoMessage() {}

func (x *GetInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetInfoRequest.ProtoReflect.Descriptor instead.
func (*GetInfoRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{22}
}

type GetInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The version of this instance of xud.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The node pub key of this node.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	// A list of uris that can be used to connect to this node. These are shared with peers.
	Uris []string `protobuf:"bytes,3,rep,name=uris,proto3" json:"uris,omitempty"`
	// The number of currently connected peers.
	NumPeers uint32 `protobuf:"varint,4,opt,name=num_peers,proto3" json:"num_peers,omitempty"`
	// The number of supported trading pairs.
	NumPairs uint32 `protobuf:"varint,5,opt,name=num_pairs,proto3" json:"num_pairs,omitempty"`
	// The number of active, standing orders in the order book.
	Orders *OrdersCount        `protobuf:"bytes,6,opt,name=orders,proto3" json:"orders,omitempty"`
	Lnd    map[string]*LndInfo `protobuf:"bytes,7,rep,name=lnd,proto3" json:"lnd,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The alias of this instance of xud.
	Alias string `protobuf:"bytes,9,opt,name=alias,proto3" json:"alias,omitempty"`
	// The network of this node.
	Network           string       `protobuf:"bytes,10,opt,name=network,proto3" json:"network,omitempty"`
	PendingSwapHashes []string     `protobuf:"bytes,11,rep,name=pending_swap_hashes,proto3" json:"pending_swap_hashes,omitempty"`
	Connext           *ConnextInfo `protobuf:"bytes,12,opt,name=connext,proto3" json:"connext,omitempty"`
}

func (x *GetInfoResponse) Reset() {
	*x = GetInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetInfoResponse) ProtoMessage() {}

func (x *GetInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetInfoResponse.ProtoReflect.Descriptor instead.
func (*GetInfoResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{23}
}

func (x *GetInfoResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *GetInfoResponse) GetNodePubKey() string {
	if x != nil {
		return x.NodePubKey
	}
	return ""
}

func (x *GetInfoResponse) GetUris() []string {
	if x != nil {
		return x.Uris
	}
	return nil
}

func (x *GetInfoResponse) GetNumPeers() uint32 {
	if x != nil {
		return x.NumPeers
	}
	return 0
}

func (x *GetInfoResponse) GetNumPairs() uint32 {
	if x != nil {
		return x.NumPairs
	}
	return 0
}

func (x *GetInfoResponse) GetOrders() *OrdersCount {
	if x != nil {
		return x.Orders
	}
	return nil
}

func (x *GetInfoResponse) GetLnd() map[string]*LndInfo {
	if x != nil {
		return x.Lnd
	}
	return nil
}

func (x *GetInfoResponse) GetAlias() string {
	if x != nil {
		return x.Alias
	}
	return ""
}

func (x *GetInfoResponse) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *GetInfoResponse) GetPendingSwapHashes() []string {
	if x != nil {
		return x.PendingSwapHashes
	}
	return nil
}

func (x *GetInfoResponse) GetConnext() *ConnextInfo {
	if x != nil {
		return x.Connext
	}
	return nil
}

type GetNodeInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node pub key or alias of the node for which to get information.
	NodeIdentifier string `protobuf:"bytes,1,opt,name=node_identifier,proto3" json:"node_identifier,omitempty"`
}

func (x *GetNodeInfoRequest) Reset() {
	*x = GetNodeInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetNodeInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNodeInfoRequest) ProtoMessage() {}

func (x *GetNodeInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNodeInfoRequest.ProtoReflect.Descriptor instead.
func (*GetNodeInfoRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{24}
}

func (x *GetNodeInfoRequest) GetNodeIdentifier() string {
	if x != nil {
		return x.NodeIdentifier
	}
	return ""
}

type GetNodeInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node's reputation score. Points are subtracted for unexpected or potentially malicious
	// behavior. Points are added when swaps are successfully executed.
	ReputationScore int32 `protobuf:"zigzag32,1,opt,name=reputationScore,json=reputation,proto3" json:"reputationScore,omitempty"`
	// Whether the node is currently banned.
	Banned bool `protobuf:"varint,2,opt,name=banned,proto3" json:"banned,omitempty"`
}

func (x *GetNodeInfoResponse) Reset() {
	*x = GetNodeInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetNodeInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNodeInfoResponse) ProtoMessage() {}

func (x *GetNodeInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNodeInfoResponse.ProtoReflect.Descriptor instead.
func (*GetNodeInfoResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{25}
}

func (x *GetNodeInfoResponse) GetReputationScore() int32 {
	if x != nil {
		return x.ReputationScore
	}
	return 0
}

func (x *GetNodeInfoResponse) GetBanned() bool {
	if x != nil {
		return x.Banned
	}
	return false
}

type ListCurrenciesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ListCurrenciesRequest) Reset() {
	*x = ListCurrenciesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListCurrenciesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCurrenciesRequest) ProtoMessage() {}

func (x *ListCurrenciesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCurrenciesRequest.ProtoReflect.Descriptor instead.
func (*ListCurrenciesRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{26}
}

type ListCurrenciesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of available currencies in the orderbook.
	Currencies []*Currency `protobuf:"bytes,1,rep,name=currencies,proto3" json:"currencies,omitempty"`
}

func (x *ListCurrenciesResponse) Reset() {
	*x = ListCurrenciesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListCurrenciesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCurrenciesResponse) ProtoMessage() {}

func (x *ListCurrenciesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCurrenciesResponse.ProtoReflect.Descriptor instead.
func (*ListCurrenciesResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{27}
}

func (x *ListCurrenciesResponse) GetCurrencies() []*Currency {
	if x != nil {
		return x.Currencies
	}
	return nil
}

type ListOrdersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The trading pair for which to retrieve orders.
	PairId string `protobuf:"bytes,1,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// Whether only own, only peer or both orders should be included in result.
	Owner ListOrdersRequest_Owner `protobuf:"varint,2,opt,name=owner,proto3,enum=xudrpc.ListOrdersRequest_Owner" json:"owner,omitempty"`
	// The maximum number of orders to return from each side of the order book.
	Limit uint32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// Whether to include the node aliases of owners of the orders.
	IncludeAliases bool `protobuf:"varint,4,opt,name=include_aliases,proto3" json:"include_aliases,omitempty"`
}

func (x *ListOrdersRequest) Reset() {
	*x = ListOrdersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListOrdersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrdersRequest) ProtoMessage() {}

func (x *ListOrdersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrdersRequest.ProtoReflect.Descriptor instead.
func (*ListOrdersRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{28}
}

func (x *ListOrdersRequest) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *ListOrdersRequest) GetOwner() ListOrdersRequest_Owner {
	if x != nil {
		return x.Owner
	}
	return ListOrdersRequest_BOTH
}

func (x *ListOrdersRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListOrdersRequest) GetIncludeAliases() bool {
	if x != nil {
		return x.IncludeAliases
	}
	return false
}

type ListOrdersResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map between pair ids and their buy and sell orders.
	Orders map[string]*Orders `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *ListOrdersResponse) Reset() {
	*x = ListOrdersResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListOrdersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrdersResponse) ProtoMessage() {}

func (x *ListOrdersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrdersResponse.ProtoReflect.Descriptor instead.
func (*ListOrdersResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{29}
}

func (x *ListOrdersResponse) GetOrders() map[string]*Orders {
	if x != nil {
		return x.Orders
	}
	return nil
}

type ListPairsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ListPairsRequest) Reset() {
	*x = ListPairsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListPairsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPairsRequest) ProtoMessage() {}

func (x *ListPairsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPairsRequest.ProtoReflect.Descriptor instead.
func (*ListPairsRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{30}
}

type ListPairsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of supported trading pair tickers in formats like "LTC/BTC".
	Pairs []string `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs,omitempty"`
}

func (x *ListPairsResponse) Reset() {
	*x = ListPairsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListPairsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPairsResponse) ProtoMessage() {}

func (x *ListPairsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPairsResponse.ProtoReflect.Descriptor instead.
func (*ListPairsResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{31}
}

func (x *ListPairsResponse) GetPairs() []string {
	if x != nil {
		return x.Pairs
	}
	return nil
}

type ListPeersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ListPeersRequest) Reset() {
	*x = ListPeersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListPeersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPeersRequest) ProtoMessage() {}

func (x *ListPeersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPeersRequest.ProtoReflect.Descriptor instead.
func (*ListPeersRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{32}
}

type ListPeersResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of connected peers.
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (x *ListPeersResponse) Reset() {
	*x = ListPeersResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListPeersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPeersResponse) ProtoMessage() {}

func (x *ListPeersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPeersResponse.ProtoReflect.Descriptor instead.
func (*ListPeersResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{33}
}

func (x *ListPeersResponse) GetPeers() []*Peer {
	if x != nil {
		return x.Peers
	}
	return nil
}

type LndInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Status      string    `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Channels    *Channels `protobuf:"bytes,2,opt,name=channels,proto3" json:"channels,omitempty"`
	Chains      []*Chain  `protobuf:"bytes,3,rep,name=chains,proto3" json:"chains,omitempty"`
	Blockheight uint32    `protobuf:"varint,4,opt,name=blockheight,proto3" json:"blockheight,omitempty"`
	Uris        []string  `protobuf:"bytes,5,rep,name=uris,proto3" json:"uris,omitempty"`
	Version     string    `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	Alias       string    `protobuf:"bytes,7,opt,name=alias,proto3" json:"alias,omitempty"`
}

func (x *LndInfo) Reset() {
	*x = LndInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LndInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LndInfo) ProtoMessage() {}

func (x *LndInfo) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LndInfo.ProtoReflect.Descriptor instead.
func (*LndInfo) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{34}
}

func (x *LndInfo) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *LndInfo) GetChannels() *Channels {
	if x != nil {
		return x.Channels
	}
	return nil
}

func (x *LndInfo) GetChains() []*Chain {
	if x != nil {
		return x.Chains
	}
	return nil
}

func (x *LndInfo) GetBlockheight() uint32 {
	if x != nil {
		return x.Blockheight
	}
	return 0
}

func (x *LndInfo) GetUris() []string {
	if x != nil {
		return x.Uris
	}
	return nil
}

func (x *LndInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *LndInfo) GetAlias() string {
	if x != nil {
		return x.Alias
	}
	return ""
}

type NodeIdentifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The pub key of this node
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	// An alias for this node deterministically generated from the pub key
	Alias string `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
}

func (x *NodeIdentifier) Reset() {
	*x = NodeIdentifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NodeIdentifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeIdentifier) ProtoMessage() {}

func (x *NodeIdentifier) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeIdentifier.ProtoReflect.Descriptor instead.
func (*NodeIdentifier) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{35}
}

func (x *NodeIdentifier) GetNodePubKey() string {
	if x != nil {
		return x.NodePubKey
	}
	return ""
}

func (x *NodeIdentifier) GetAlias() string {
	if x != nil {
		return x.Alias
	}
	return ""
}

type OpenChannelRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node pub key or alias of the peer with which to open channel with.
	NodeIdentifier string `protobuf:"bytes,1,opt,name=node_identifier,proto3" json:"node_identifier,omitempty"`
	// The ticker symbol of the currency to open the channel for.
	Currency string `protobuf:"bytes,2,opt,name=currency,proto3" json:"currency,omitempty"`
	// The amount to be deposited into the channel denominated in satoshis.
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// The balance amount to be pushed to the remote side of the channel denominated in satoshis.
	PushAmount uint64 `protobuf:"varint,4,opt,name=push_amount,proto3" json:"push_amount,omitempty"`
}

func (x *OpenChannelRequest) Reset() {
	*x = OpenChannelRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OpenChannelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenChannelRequest) ProtoMessage() {}

func (x *OpenChannelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenChannelRequest.ProtoReflect.Descriptor instead.
func (*OpenChannelRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{36}
}

func (x *OpenChannelRequest) GetNodeIdentifier() string {
	if x != nil {
		return x.NodeIdentifier
	}
	return ""
}

func (x *OpenChannelRequest) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *OpenChannelRequest) GetAmount() uint64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *OpenChannelRequest) GetPushAmount() uint64 {
	if x != nil {
		return x.PushAmount
	}
	return 0
}

type OpenChannelResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The id of the transaction that opened the channel.
	TransactionId string `protobuf:"bytes,1,opt,name=transaction_id,proto3" json:"transaction_id,omitempty"`
}

func (x *OpenChannelResponse) Reset() {
	*x = OpenChannelResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OpenChannelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenChannelResponse) ProtoMessage() {}

func (x *OpenChannelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenChannelResponse.ProtoReflect.Descriptor instead.
func (*OpenChannelResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{37}
}

func (x *OpenChannelResponse) GetTransactionId() string {
	if x != nil {
		return x.TransactionId
	}
	return ""
}

type Order struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price,proto3" json:"price,omitempty"`
	// The quantity of the order in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair that this order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// A UUID for this order.
	Id string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// The identifier of the node that created this order.
	NodeIdentifier *NodeIdentifier `protobuf:"bytes,5,opt,name=node_identifier,proto3" json:"node_identifier,omitempty"`
	// The local id for this order, if applicable.
	LocalId string `protobuf:"bytes,6,opt,name=local_id,proto3" json:"local_id,omitempty"`
	// The epoch time in milliseconds when this order was created.
	CreatedAt uint64 `protobuf:"varint,7,opt,name=created_at,proto3" json:"created_at,omitempty"`
	// Whether this order is a buy or sell
	Side OrderSide `protobuf:"varint,8,opt,name=side,proto3,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// Whether this order is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,9,opt,name=is_own_order,proto3" json:"is_own_order,omitempty"`
	// The quantity on hold pending swap execution.
	Hold uint64 `protobuf:"varint,10,opt,name=hold,proto3" json:"hold,omitempty"`
}

func (x *Order) Reset() {
	*x = Order{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Order) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Order) ProtoMessage() {}

func (x *Order) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Order.ProtoReflect.Descriptor instead.
func (*Order) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{38}
}

func (x *Order) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *Order) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *Order) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *Order) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Order) GetNodeIdentifier() *NodeIdentifier {
	if x != nil {
		return x.NodeIdentifier
	}
	return nil
}

func (x *Order) GetLocalId() string {
	if x != nil {
		return x.LocalId
	}
	return ""
}

func (x *Order) GetCreatedAt() uint64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *Order) GetSide() OrderSide {
	if x != nil {
		return x.Side
	}
	return OrderSide_BUY
}

func (x *Order) GetIsOwnOrder() bool {
	if x != nil {
		return x.IsOwnOrder
	}
	return false
}

func (x *Order) GetHold() uint64 {
	if x != nil {
		return x.Hold
	}
	return 0
}

type OrderRemoval struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The quantity removed from the order.
	Quantity uint64 `protobuf:"varint,1,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The global UUID for the order.
	OrderId string `protobuf:"bytes,3,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The local id for the order, if applicable.
	LocalId string `protobuf:"bytes,4,opt,name=local_id,proto3" json:"local_id,omitempty"`
	// Whether the order being removed is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,5,opt,name=is_own_order,proto3" json:"is_own_order,omitempty"`
}

func (x *OrderRemoval) Reset() {
	*x = OrderRemoval{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OrderRemoval) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderRemoval) ProtoMessage() {}

func (x *OrderRemoval) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderRemoval.ProtoReflect.Descriptor instead.
func (*OrderRemoval) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{39}
}

func (x *OrderRemoval) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *OrderRemoval) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *OrderRemoval) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *OrderRemoval) GetLocalId() string {
	if x != nil {
		return x.LocalId
	}
	return ""
}

func (x *OrderRemoval) GetIsOwnOrder() bool {
	if x != nil {
		return x.IsOwnOrder
	}
	return false
}

type Orders struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A list of buy orders sorted by descending price.
	BuyOrders []*Order `protobuf:"bytes,1,rep,name=buy_orders,proto3" json:"buy_orders,omitempty"`
	// A list of sell orders sorted by ascending price.
	SellOrders []*Order `protobuf:"bytes,2,rep,name=sell_orders,proto3" json:"sell_orders,omitempty"`
}

func (x *Orders) Reset() {
	*x = Orders{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Orders) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Orders) ProtoMessage() {}

func (x *Orders) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Orders.ProtoReflect.Descriptor instead.
func (*Orders) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{40}
}

func (x *Orders) GetBuyOrders() []*Order {
	if x != nil {
		return x.BuyOrders
	}
	return nil
}

func (x *Orders) GetSellOrders() []*Order {
	if x != nil {
		return x.SellOrders
	}
	return nil
}

type OrdersCount struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The number of orders belonging to remote xud nodes.
	Peer uint32 `protobuf:"varint,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// The number of orders belonging to our local xud node.
	Own uint32 `protobuf:"varint,2,opt,name=own,proto3" json:"own,omitempty"`
}

func (x *OrdersCount) Reset() {
	*x = OrdersCount{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OrdersCount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrdersCount) ProtoMessage() {}

func (x *OrdersCount) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrdersCount.ProtoReflect.Descriptor instead.
func (*OrdersCount) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{41}
}

func (x *OrdersCount) GetPeer() uint32 {
	if x != nil {
		return x.Peer
	}
	return 0
}

func (x *OrdersCount) GetOwn() uint32 {
	if x != nil {
		return x.Own
	}
	return 0
}

type OrderUpdate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to OrderUpdate:
	//	*OrderUpdate_Order
	//	*OrderUpdate_OrderRemoval
	OrderUpdate isOrderUpdate_OrderUpdate `protobuf_oneof:"order_update"`
}

func (x *OrderUpdate) Reset() {
	*x = OrderUpdate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OrderUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderUpdate) ProtoMessage() {}

func (x *OrderUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderUpdate.ProtoReflect.Descriptor instead.
func (*OrderUpdate) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{42}
}

func (m *OrderUpdate) GetOrderUpdate() isOrderUpdate_OrderUpdate {
	if m != nil {
		return m.OrderUpdate
	}
	return nil
}

func (x *OrderUpdate) GetOrder() *Order {
	if x, ok := x.GetOrderUpdate().(*OrderUpdate_Order); ok {
		return x.Order
	}
	return nil
}

func (x *OrderUpdate) GetOrderRemoval() *OrderRemoval {
	if x, ok := x.GetOrderUpdate().(*OrderUpdate_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

type isOrderUpdate_OrderUpdate interface {
	isOrderUpdate_OrderUpdate()
}

type OrderUpdate_Order struct {
	// An order that was added to the order book.
	Order *Order `protobuf:"bytes,1,opt,name=order,proto3,oneof"`
}

type OrderUpdate_OrderRemoval struct {
	// An order (or portion thereof) that was removed from the order book.
	OrderRemoval *OrderRemoval `protobuf:"bytes,2,opt,name=order_removal,proto3,oneof"`
}

func (*OrderUpdate_Order) isOrderUpdate_OrderUpdate() {}

func (*OrderUpdate_OrderRemoval) isOrderUpdate_OrderUpdate() {}

type Peer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The socket address with host and port for this peer.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The node pub key to uniquely identify this peer.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	// A map of ticker symbols to lnd pub keys for this peer
	LndPubKeys map[string]string `protobuf:"bytes,3,rep,name=lnd_pub_keys,proto3" json:"lnd_pub_keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Indicates whether this peer was connected inbound.
	Inbound bool `protobuf:"varint,4,opt,name=inbound,proto3" json:"inbound,omitempty"`
	// A list of trading pair tickers supported by this peer.
	Pairs []string `protobuf:"bytes,5,rep,name=pairs,proto3" json:"pairs,omitempty"`
	// The version of xud being used by the peer.
	XudVersion string `protobuf:"bytes,6,opt,name=xud_version,proto3" json:"xud_version,omitempty"`
	// The time in seconds that we have been connected to this peer.
	SecondsConnected uint32 `protobuf:"varint,7,opt,name=seconds_connected,proto3" json:"seconds_connected,omitempty"`
	// The alias for this peer's public key
	Alias string `protobuf:"bytes,9,opt,name=alias,proto3" json:"alias,omitempty"`
}

func (x *Peer) Reset() {
	*x = Peer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Peer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Peer) ProtoMessage() {}

func (x *Peer) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Peer.ProtoReflect.Descriptor instead.
func (*Peer) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{43}
}

func (x *Peer) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Peer) GetNodePubKey() string {
	if x != nil {
		return x.NodePubKey
	}
	return ""
}

func (x *Peer) GetLndPubKeys() map[string]string {
	if x != nil {
		return x.LndPubKeys
	}
	return nil
}

func (x *Peer) GetInbound() bool {
	if x != nil {
		return x.Inbound
	}
	return false
}

func (x *Peer) GetPairs() []string {
	if x != nil {
		return x.Pairs
	}
	return nil
}

func (x *Peer) GetXudVersion() string {
	if x != nil {
		return x.XudVersion
	}
	return ""
}

func (x *Peer) GetSecondsConnected() uint32 {
	if x != nil {
		return x.SecondsConnected
	}
	return 0
}

func (x *Peer) GetAlias() string {
	if x != nil {
		return x.Alias
	}
	return ""
}

type PlaceOrderRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price,proto3" json:"price,omitempty"`
	// The quantity of the order denominated in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The local id to assign to the order.
	OrderId string `protobuf:"bytes,4,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// Whether the order is a buy or sell.
	Side OrderSide `protobuf:"varint,5,opt,name=side,proto3,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// The local id of an existing order to be replaced. If provided, the order must be successfully
	// found and removed before the new order is placed, otherwise an error is returned.
	ReplaceOrderId string `protobuf:"bytes,6,opt,name=replace_order_id,proto3" json:"replace_order_id,omitempty"`
	// Whether the order must be filled immediately and not allowed to enter the order book.
	ImmediateOrCancel bool `protobuf:"varint,7,opt,name=immediate_or_cancel,proto3" json:"immediate_or_cancel,omitempty"`
}

func (x *PlaceOrderRequest) Reset() {
	*x = PlaceOrderRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PlaceOrderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaceOrderRequest) ProtoMessage() {}

func (x *PlaceOrderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaceOrderRequest.ProtoReflect.Descriptor instead.
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{44}
}

func (x *PlaceOrderRequest) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *PlaceOrderRequest) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *PlaceOrderRequest) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *PlaceOrderRequest) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *PlaceOrderRequest) GetSide() OrderSide {
	if x != nil {
		return x.Side
	}
	return OrderSide_BUY
}

func (x *PlaceOrderRequest) GetReplaceOrderId() string {
	if x != nil {
		return x.ReplaceOrderId
	}
	return ""
}

func (x *PlaceOrderRequest) GetImmediateOrCancel() bool {
	if x != nil {
		return x.ImmediateOrCancel
	}
	return false
}

type PlaceOrderResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A list of own orders (or portions thereof) that matched the newly placed order.
	InternalMatches []*Order `protobuf:"bytes,1,rep,name=internal_matches,proto3" json:"internal_matches,omitempty"`
	// A list of successful swaps of peer orders that matched the newly placed order.
	SwapSuccesses []*SwapSuccess `protobuf:"bytes,2,rep,name=swap_successes,proto3" json:"swap_successes,omitempty"`
	// The remaining portion of the order, after matches, that enters the order book.
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order,proto3" json:"remaining_order,omitempty"`
	// A list of swap attempts that failed.
	SwapFailures []*SwapFailure `protobuf:"bytes,4,rep,name=swap_failures,proto3" json:"swap_failures,omitempty"`
}

func (x *PlaceOrderResponse) Reset() {
	*x = PlaceOrderResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[45]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PlaceOrderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaceOrderResponse) ProtoMessage() {}

func (x *PlaceOrderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[45]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaceOrderResponse.ProtoReflect.Descriptor instead.
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{45}
}

func (x *PlaceOrderResponse) GetInternalMatches() []*Order {
	if x != nil {
		return x.InternalMatches
	}
	return nil
}

func (x *PlaceOrderResponse) GetSwapSuccesses() []*SwapSuccess {
	if x != nil {
		return x.SwapSuccesses
	}
	return nil
}

func (x *PlaceOrderResponse) GetRemainingOrder() *Order {
	if x != nil {
		return x.RemainingOrder
	}
	return nil
}

func (x *PlaceOrderResponse) GetSwapFailures() []*SwapFailure {
	if x != nil {
		return x.SwapFailures
	}
	return nil
}

type PlaceOrderEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Event:
	//	*PlaceOrderEvent_Match
	//	*PlaceOrderEvent_SwapSuccess
	//	*PlaceOrderEvent_RemainingOrder
	//	*PlaceOrderEvent_SwapFailure
	Event isPlaceOrderEvent_Event `protobuf_oneof:"event"`
}

func (x *PlaceOrderEvent) Reset() {
	*x = PlaceOrderEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[46]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PlaceOrderEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlaceOrderEvent) ProtoMessage() {}

func (x *PlaceOrderEvent) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[46]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlaceOrderEvent.ProtoReflect.Descriptor instead.
func (*PlaceOrderEvent) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{46}
}

func (m *PlaceOrderEvent) GetEvent() isPlaceOrderEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (x *PlaceOrderEvent) GetMatch() *Order {
	if x, ok := x.GetEvent().(*PlaceOrderEvent_Match); ok {
		return x.Match
	}
	return nil
}

func (x *PlaceOrderEvent) GetSwapSuccess() *SwapSuccess {
	if x, ok := x.GetEvent().(*PlaceOrderEvent_SwapSuccess); ok {
		return x.SwapSuccess
	}
	return nil
}

func (x *PlaceOrderEvent) GetRemainingOrder() *Order {
	if x, ok := x.GetEvent().(*PlaceOrderEvent_RemainingOrder); ok {
		return x.RemainingOrder
	}
	return nil
}

func (x *PlaceOrderEvent) GetSwapFailure() *SwapFailure {
	if x, ok := x.GetEvent().(*PlaceOrderEvent_SwapFailure); ok {
		return x.SwapFailure
	}
	return nil
}

type isPlaceOrderEvent_Event interface {
	isPlaceOrderEvent_Event()
}

type PlaceOrderEvent_Match struct {
	// An order (or portion thereof) that matched the newly placed order.
	Match *Order `protobuf:"bytes,1,opt,name=match,proto3,oneof"`
}

type PlaceOrderEvent_SwapSuccess struct {
	// A successful swap of a peer order that matched the newly placed order.
	SwapSuccess *SwapSuccess `protobuf:"bytes,2,opt,name=swap_success,proto3,oneof"`
}

type PlaceOrderEvent_RemainingOrder struct {
	// The remaining portion of the order, after matches, that enters the order book.
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order,proto3,oneof"`
}

type PlaceOrderEvent_SwapFailure struct {
	// A swap attempt that failed.
	SwapFailure *SwapFailure `protobuf:"bytes,4,opt,name=swap_failure,proto3,oneof"`
}

func (*PlaceOrderEvent_Match) isPlaceOrderEvent_Event() {}

func (*PlaceOrderEvent_SwapSuccess) isPlaceOrderEvent_Event() {}

func (*PlaceOrderEvent_RemainingOrder) isPlaceOrderEvent_Event() {}

func (*PlaceOrderEvent_SwapFailure) isPlaceOrderEvent_Event() {}

type ConnextInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Status  string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Chain   string `protobuf:"bytes,5,opt,name=chain,proto3" json:"chain,omitempty"`
}

func (x *ConnextInfo) Reset() {
	*x = ConnextInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[47]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConnextInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnextInfo) ProtoMessage() {}

func (x *ConnextInfo) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[47]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnextInfo.ProtoReflect.Descriptor instead.
func (*ConnextInfo) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{47}
}

func (x *ConnextInfo) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *ConnextInfo) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *ConnextInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ConnextInfo) GetChain() string {
	if x != nil {
		return x.Chain
	}
	return ""
}

type RemoveCurrencyRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (x *RemoveCurrencyRequest) Reset() {
	*x = RemoveCurrencyRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[48]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveCurrencyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveCurrencyRequest) ProtoMessage() {}

func (x *RemoveCurrencyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[48]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveCurrencyRequest.ProtoReflect.Descriptor instead.
func (*RemoveCurrencyRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{48}
}

func (x *RemoveCurrencyRequest) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

type RemoveCurrencyResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *RemoveCurrencyResponse) Reset() {
	*x = RemoveCurrencyResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[49]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveCurrencyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveCurrencyResponse) ProtoMessage() {}

func (x *RemoveCurrencyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[49]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveCurrencyResponse.ProtoReflect.Descriptor instead.
func (*RemoveCurrencyResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{49}
}

type RemoveOrderRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The local id of the order to remove.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The quantity to remove from the order denominated in satoshis.
	// If zero or unspecified then the entire order is removed.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
}

func (x *RemoveOrderRequest) Reset() {
	*x = RemoveOrderRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[50]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveOrderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveOrderRequest) ProtoMessage() {}

func (x *RemoveOrderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[50]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveOrderRequest.ProtoReflect.Descriptor instead.
func (*RemoveOrderRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{50}
}

func (x *RemoveOrderRequest) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *RemoveOrderRequest) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type RemoveOrderResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Any portion of the order that was on hold due to ongoing swaps at the time of the request
	// and could not be removed until after the swaps finish.
	QuantityOnHold uint64 `protobuf:"varint,1,opt,name=quantity_on_hold,json=hold,proto3" json:"quantity_on_hold,omitempty"`
}

func (x *RemoveOrderResponse) Reset() {
	*x = RemoveOrderResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[51]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveOrderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveOrderResponse) ProtoMessage() {}

func (x *RemoveOrderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[51]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveOrderResponse.ProtoReflect.Descriptor instead.
func (*RemoveOrderResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{51}
}

func (x *RemoveOrderResponse) GetQuantityOnHold() uint64 {
	if x != nil {
		return x.QuantityOnHold
	}
	return 0
}

type RemovePairRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The trading pair ticker to remove in a format such as "LTC/BTC".
	PairId string `protobuf:"bytes,1,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
}

func (x *RemovePairRequest) Reset() {
	*x = RemovePairRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[52]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemovePairRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemovePairRequest) ProtoMessage() {}

func (x *RemovePairRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[52]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemovePairRequest.ProtoReflect.Descriptor instead.
func (*RemovePairRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{52}
}

func (x *RemovePairRequest) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

type RemovePairResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *RemovePairResponse) Reset() {
	*x = RemovePairResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[53]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemovePairResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemovePairResponse) ProtoMessage() {}

func (x *RemovePairResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[53]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemovePairResponse.ProtoReflect.Descriptor instead.
func (*RemovePairResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{53}
}

type RestoreNodeRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The 24 word mnemonic to recover the xud identity key and underlying wallets
	SeedMnemonic []string `protobuf:"bytes,1,rep,name=seed_mnemonic,json=seedMnemonic,proto3" json:"seed_mnemonic,omitempty"`
	// The password in utf-8 with which to encrypt the restored xud node key as well
	// as any restored underlying wallets.
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	// A map between the currency of the LND and its multi channel SCB
	LndBackups map[string][]byte `protobuf:"bytes,3,rep,name=lnd_backups,json=lndBackups,proto3" json:"lnd_backups,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The XUD database backup
	XudDatabase []byte `protobuf:"bytes,6,opt,name=xud_database,json=xudDatabase,proto3" json:"xud_database,omitempty"`
}

func (x *RestoreNodeRequest) Reset() {
	*x = RestoreNodeRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[54]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RestoreNodeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestoreNodeRequest) ProtoMessage() {}

func (x *RestoreNodeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[54]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RestoreNodeRequest.ProtoReflect.Descriptor instead.
func (*RestoreNodeRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{54}
}

func (x *RestoreNodeRequest) GetSeedMnemonic() []string {
	if x != nil {
		return x.SeedMnemonic
	}
	return nil
}

func (x *RestoreNodeRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *RestoreNodeRequest) GetLndBackups() map[string][]byte {
	if x != nil {
		return x.LndBackups
	}
	return nil
}

func (x *RestoreNodeRequest) GetXudDatabase() []byte {
	if x != nil {
		return x.XudDatabase
	}
	return nil
}

type RestoreNodeResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of lnd clients that were initialized.
	RestoredLnds []string `protobuf:"bytes,1,rep,name=restored_lnds,json=restoredLnds,proto3" json:"restored_lnds,omitempty"`
}

func (x *RestoreNodeResponse) Reset() {
	*x = RestoreNodeResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[55]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RestoreNodeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestoreNodeResponse) ProtoMessage() {}

func (x *RestoreNodeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[55]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RestoreNodeResponse.ProtoReflect.Descriptor instead.
func (*RestoreNodeResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{55}
}

func (x *RestoreNodeResponse) GetRestoredLnds() []string {
	if x != nil {
		return x.RestoredLnds
	}
	return nil
}

type ShutdownRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ShutdownRequest) Reset() {
	*x = ShutdownRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[56]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ShutdownRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShutdownRequest) ProtoMessage() {}

func (x *ShutdownRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[56]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShutdownRequest.ProtoReflect.Descriptor instead.
func (*ShutdownRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{56}
}

type ShutdownResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ShutdownResponse) Reset() {
	*x = ShutdownResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[57]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ShutdownResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShutdownResponse) ProtoMessage() {}

func (x *ShutdownResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[57]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShutdownResponse.ProtoReflect.Descriptor instead.
func (*ShutdownResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{57}
}

type SubscribeOrdersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether to transmit all existing active orders upon establishing the stream.
	Existing bool `protobuf:"varint,1,opt,name=existing,proto3" json:"existing,omitempty"`
}

func (x *SubscribeOrdersRequest) Reset() {
	*x = SubscribeOrdersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[58]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SubscribeOrdersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeOrdersRequest) ProtoMessage() {}

func (x *SubscribeOrdersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[58]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeOrdersRequest.ProtoReflect.Descriptor instead.
func (*SubscribeOrdersRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{58}
}

func (x *SubscribeOrdersRequest) GetExisting() bool {
	if x != nil {
		return x.Existing
	}
	return false
}

type SubscribeSwapsAcceptedRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SubscribeSwapsAcceptedRequest) Reset() {
	*x = SubscribeSwapsAcceptedRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[59]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SubscribeSwapsAcceptedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeSwapsAcceptedRequest) ProtoMessage() {}

func (x *SubscribeSwapsAcceptedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[59]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeSwapsAcceptedRequest.ProtoReflect.Descriptor instead.
func (*SubscribeSwapsAcceptedRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{59}
}

type SubscribeSwapsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether to include the results for swaps initiated via the PlaceOrder or ExecuteSwap calls.
	// These swap results are also returned in the responses for the respective calls.
	IncludeTaker bool `protobuf:"varint,1,opt,name=include_taker,proto3" json:"include_taker,omitempty"`
}

func (x *SubscribeSwapsRequest) Reset() {
	*x = SubscribeSwapsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[60]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SubscribeSwapsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeSwapsRequest) ProtoMessage() {}

func (x *SubscribeSwapsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[60]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeSwapsRequest.ProtoReflect.Descriptor instead.
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{60}
}

func (x *SubscribeSwapsRequest) GetIncludeTaker() bool {
	if x != nil {
		return x.IncludeTaker
	}
	return false
}

type SwapAccepted struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The global UUID for the order that was accepted to be swapped.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// The local id for the order that was accepted to be swapped.
	LocalId string `protobuf:"bytes,2,opt,name=local_id,proto3" json:"local_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The order quantity that was accepted to be swapped.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The price for the swap.
	Price float64 `protobuf:"fixed64,5,opt,name=price,proto3" json:"price,omitempty"`
	// The node pub key of the peer that executed this order.
	PeerPubKey string `protobuf:"bytes,6,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	// The hex-encoded payment hash for the swap.
	RHash string `protobuf:"bytes,7,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// The amount received denominated in satoshis.
	AmountReceiving uint64 `protobuf:"varint,8,opt,name=amount_receiving,proto3" json:"amount_receiving,omitempty"`
	// The amount sent denominated in satoshis.
	AmountSending uint64 `protobuf:"varint,9,opt,name=amount_sending,proto3" json:"amount_sending,omitempty"`
	// The ticker symbol of the currency received.
	CurrencyReceiving string `protobuf:"bytes,10,opt,name=currency_receiving,proto3" json:"currency_receiving,omitempty"`
	// The ticker symbol of the currency sent.
	CurrencySending string `protobuf:"bytes,11,opt,name=currency_sending,proto3" json:"currency_sending,omitempty"`
}

func (x *SwapAccepted) Reset() {
	*x = SwapAccepted{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[61]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SwapAccepted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwapAccepted) ProtoMessage() {}

func (x *SwapAccepted) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[61]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwapAccepted.ProtoReflect.Descriptor instead.
func (*SwapAccepted) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{61}
}

func (x *SwapAccepted) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *SwapAccepted) GetLocalId() string {
	if x != nil {
		return x.LocalId
	}
	return ""
}

func (x *SwapAccepted) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *SwapAccepted) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *SwapAccepted) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *SwapAccepted) GetPeerPubKey() string {
	if x != nil {
		return x.PeerPubKey
	}
	return ""
}

func (x *SwapAccepted) GetRHash() string {
	if x != nil {
		return x.RHash
	}
	return ""
}

func (x *SwapAccepted) GetAmountReceiving() uint64 {
	if x != nil {
		return x.AmountReceiving
	}
	return 0
}

func (x *SwapAccepted) GetAmountSending() uint64 {
	if x != nil {
		return x.AmountSending
	}
	return 0
}

func (x *SwapAccepted) GetCurrencyReceiving() string {
	if x != nil {
		return x.CurrencyReceiving
	}
	return ""
}

func (x *SwapAccepted) GetCurrencySending() string {
	if x != nil {
		return x.CurrencySending
	}
	return ""
}

type SwapFailure struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The global UUID for the order that failed the swap.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The order quantity that was attempted to be swapped.
	Quantity uint64 `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The node pub key of the peer that we attempted to swap with.
	PeerPubKey string `protobuf:"bytes,4,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	// The reason why the swap failed.
	FailureReason string `protobuf:"bytes,5,opt,name=failure_reason,proto3" json:"failure_reason,omitempty"`
}

func (x *SwapFailure) Reset() {
	*x = SwapFailure{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[62]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SwapFailure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwapFailure) ProtoMessage() {}

func (x *SwapFailure) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[62]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwapFailure.ProtoReflect.Descriptor instead.
func (*SwapFailure) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{62}
}

func (x *SwapFailure) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *SwapFailure) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *SwapFailure) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *SwapFailure) GetPeerPubKey() string {
	if x != nil {
		return x.PeerPubKey
	}
	return ""
}

func (x *SwapFailure) GetFailureReason() string {
	if x != nil {
		return x.FailureReason
	}
	return ""
}

type SwapSuccess struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The global UUID for the order that was swapped.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// The local id for the order that was swapped.
	LocalId string `protobuf:"bytes,2,opt,name=local_id,proto3" json:"local_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The order quantity that was swapped.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The hex-encoded payment hash for the swap.
	RHash string `protobuf:"bytes,5,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// The amount received denominated in satoshis.
	AmountReceived uint64 `protobuf:"varint,8,opt,name=amount_received,proto3" json:"amount_received,omitempty"`
	// The amount sent denominated in satoshis.
	AmountSent uint64 `protobuf:"varint,9,opt,name=amount_sent,proto3" json:"amount_sent,omitempty"`
	// The node pub key of the peer that executed this order.
	PeerPubKey string `protobuf:"bytes,10,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	// Our role in the swap, either MAKER or TAKER.
	Role Role `protobuf:"varint,11,opt,name=role,proto3,enum=xudrpc.Role" json:"role,omitempty"`
	// The ticker symbol of the currency received.
	CurrencyReceived string `protobuf:"bytes,12,opt,name=currency_received,proto3" json:"currency_received,omitempty"`
	// The ticker symbol of the currency sent.
	CurrencySent string `protobuf:"bytes,13,opt,name=currency_sent,proto3" json:"currency_sent,omitempty"`
	// The hex-encoded preimage.
	RPreimage string `protobuf:"bytes,14,opt,name=r_preimage,proto3" json:"r_preimage,omitempty"`
	// The price used for the swap.
	Price float64 `protobuf:"fixed64,15,opt,name=price,proto3" json:"price,omitempty"`
}

func (x *SwapSuccess) Reset() {
	*x = SwapSuccess{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[63]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SwapSuccess) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwapSuccess) ProtoMessage() {}

func (x *SwapSuccess) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[63]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwapSuccess.ProtoReflect.Descriptor instead.
func (*SwapSuccess) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{63}
}

func (x *SwapSuccess) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *SwapSuccess) GetLocalId() string {
	if x != nil {
		return x.LocalId
	}
	return ""
}

func (x *SwapSuccess) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *SwapSuccess) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *SwapSuccess) GetRHash() string {
	if x != nil {
		return x.RHash
	}
	return ""
}

func (x *SwapSuccess) GetAmountReceived() uint64 {
	if x != nil {
		return x.AmountReceived
	}
	return 0
}

func (x *SwapSuccess) GetAmountSent() uint64 {
	if x != nil {
		return x.AmountSent
	}
	return 0
}

func (x *SwapSuccess) GetPeerPubKey() string {
	if x != nil {
		return x.PeerPubKey
	}
	return ""
}

func (x *SwapSuccess) GetRole() Role {
	if x != nil {
		return x.Role
	}
	return Role_TAKER
}

func (x *SwapSuccess) GetCurrencyReceived() string {
	if x != nil {
		return x.CurrencyReceived
	}
	return ""
}

func (x *SwapSuccess) GetCurrencySent() string {
	if x != nil {
		return x.CurrencySent
	}
	return ""
}

func (x *SwapSuccess) GetRPreimage() string {
	if x != nil {
		return x.RPreimage
	}
	return ""
}

func (x *SwapSuccess) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

type Trade struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The maker order involved in this trade.
	MakerOrder *Order `protobuf:"bytes,1,opt,name=maker_order,proto3" json:"maker_order,omitempty"`
	// The taker order involved in this trade. Note that when a trade occurs from
	// a remote peer filling one of our orders, we do not receive the order (only a
	// swap request) and this field will be empty.
	TakerOrder *Order `protobuf:"bytes,2,opt,name=taker_order,proto3" json:"taker_order,omitempty"`
	// The payment hash involved in this trade.
	RHash string `protobuf:"bytes,3,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// The quantity transacted in this trade.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair for this trade.
	PairId string `protobuf:"bytes,5,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The price used for the trade.
	Price float64 `protobuf:"fixed64,6,opt,name=price,proto3" json:"price,omitempty"`
	// Our role in the trade.
	Role Role `protobuf:"varint,7,opt,name=role,proto3,enum=xudrpc.Role" json:"role,omitempty"`
	// The epoch time in milliseconds that this trade was executed
	ExecutedAt uint64 `protobuf:"varint,8,opt,name=executed_at,proto3" json:"executed_at,omitempty"`
	// Whether this node was on the buy or sell side of the trade - or both in case of internal trades.
	Side OrderSide `protobuf:"varint,9,opt,name=side,proto3,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// The counterparty to this trade, if applicable.
	Counterparty *NodeIdentifier `protobuf:"bytes,10,opt,name=counterparty,proto3" json:"counterparty,omitempty"`
}

func (x *Trade) Reset() {
	*x = Trade{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[64]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Trade) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Trade) ProtoMessage() {}

func (x *Trade) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[64]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Trade.ProtoReflect.Descriptor instead.
func (*Trade) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{64}
}

func (x *Trade) GetMakerOrder() *Order {
	if x != nil {
		return x.MakerOrder
	}
	return nil
}

func (x *Trade) GetTakerOrder() *Order {
	if x != nil {
		return x.TakerOrder
	}
	return nil
}

func (x *Trade) GetRHash() string {
	if x != nil {
		return x.RHash
	}
	return ""
}

func (x *Trade) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *Trade) GetPairId() string {
	if x != nil {
		return x.PairId
	}
	return ""
}

func (x *Trade) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *Trade) GetRole() Role {
	if x != nil {
		return x.Role
	}
	return Role_TAKER
}

func (x *Trade) GetExecutedAt() uint64 {
	if x != nil {
		return x.ExecutedAt
	}
	return 0
}

func (x *Trade) GetSide() OrderSide {
	if x != nil {
		return x.Side
	}
	return OrderSide_BUY
}

func (x *Trade) GetCounterparty() *NodeIdentifier {
	if x != nil {
		return x.Counterparty
	}
	return nil
}

type TradeHistoryRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The maximum number of trades to return
	Limit uint32 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (x *TradeHistoryRequest) Reset() {
	*x = TradeHistoryRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[65]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TradeHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradeHistoryRequest) ProtoMessage() {}

func (x *TradeHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[65]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradeHistoryRequest.ProtoReflect.Descriptor instead.
func (*TradeHistoryRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{65}
}

func (x *TradeHistoryRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type TradeHistoryResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Trades []*Trade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades,omitempty"`
}

func (x *TradeHistoryResponse) Reset() {
	*x = TradeHistoryResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[66]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TradeHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradeHistoryResponse) ProtoMessage() {}

func (x *TradeHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[66]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradeHistoryResponse.ProtoReflect.Descriptor instead.
func (*TradeHistoryResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{66}
}

func (x *TradeHistoryResponse) GetTrades() []*Trade {
	if x != nil {
		return x.Trades
	}
	return nil
}

type TradingLimits struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Max outbound capacity for a distinct channel denominated in satoshis.
	MaxSell uint64 `protobuf:"varint,1,opt,name=MaxSell,json=max_sell,proto3" json:"MaxSell,omitempty"`
	// Max inbound capacity for a distinct channel denominated in satoshis.
	MaxBuy uint64 `protobuf:"varint,2,opt,name=MaxBuy,json=max_buy,proto3" json:"MaxBuy,omitempty"`
}

func (x *TradingLimits) Reset() {
	*x = TradingLimits{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[67]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TradingLimits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradingLimits) ProtoMessage() {}

func (x *TradingLimits) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[67]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradingLimits.ProtoReflect.Descriptor instead.
func (*TradingLimits) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{67}
}

func (x *TradingLimits) GetMaxSell() uint64 {
	if x != nil {
		return x.MaxSell
	}
	return 0
}

func (x *TradingLimits) GetMaxBuy() uint64 {
	if x != nil {
		return x.MaxBuy
	}
	return 0
}

type TradingLimitsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ticker symbol of the currency to query for, if unspecified then trading limits for all supported
	// currencies are queried.
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (x *TradingLimitsRequest) Reset() {
	*x = TradingLimitsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[68]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TradingLimitsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradingLimitsRequest) ProtoMessage() {}

func (x *TradingLimitsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[68]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradingLimitsRequest.ProtoReflect.Descriptor instead.
func (*TradingLimitsRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{68}
}

func (x *TradingLimitsRequest) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

type TradingLimitsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map between currency ticker symbols and their trading limits.
	Limits map[string]*TradingLimits `protobuf:"bytes,1,rep,name=limits,proto3" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *TradingLimitsResponse) Reset() {
	*x = TradingLimitsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[69]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TradingLimitsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradingLimitsResponse) ProtoMessage() {}

func (x *TradingLimitsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[69]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradingLimitsResponse.ProtoReflect.Descriptor instead.
func (*TradingLimitsResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{69}
}

func (x *TradingLimitsResponse) GetLimits() map[string]*TradingLimits {
	if x != nil {
		return x.Limits
	}
	return nil
}

type UnbanRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The node pub key or alias of the peer to unban.
	NodeIdentifier string `protobuf:"bytes,1,opt,name=node_identifier,proto3" json:"node_identifier,omitempty"`
	// Whether to attempt to connect to the peer after it is unbanned.
	Reconnect bool `protobuf:"varint,2,opt,name=reconnect,proto3" json:"reconnect,omitempty"`
}

func (x *UnbanRequest) Reset() {
	*x = UnbanRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[70]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnbanRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnbanRequest) ProtoMessage() {}

func (x *UnbanRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[70]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnbanRequest.ProtoReflect.Descriptor instead.
func (*UnbanRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{70}
}

func (x *UnbanRequest) GetNodeIdentifier() string {
	if x != nil {
		return x.NodeIdentifier
	}
	return ""
}

func (x *UnbanRequest) GetReconnect() bool {
	if x != nil {
		return x.Reconnect
	}
	return false
}

type UnbanResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *UnbanResponse) Reset() {
	*x = UnbanResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[71]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnbanResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnbanResponse) ProtoMessage() {}

func (x *UnbanResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[71]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnbanResponse.ProtoReflect.Descriptor instead.
func (*UnbanResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{71}
}

type UnlockNodeRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The password in utf-8 with which to unlock an existing xud node key as
	// well as underlying client wallets such as lnd.
	Password string `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *UnlockNodeRequest) Reset() {
	*x = UnlockNodeRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[72]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnlockNodeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnlockNodeRequest) ProtoMessage() {}

func (x *UnlockNodeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[72]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnlockNodeRequest.ProtoReflect.Descriptor instead.
func (*UnlockNodeRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{72}
}

func (x *UnlockNodeRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type UnlockNodeResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of lnd clients that were unlocked.
	UnlockedLnds []string `protobuf:"bytes,1,rep,name=unlocked_lnds,json=unlockedLnds,proto3" json:"unlocked_lnds,omitempty"`
	// The list of lnd clients that could not be unlocked.
	LockedLnds []string `protobuf:"bytes,3,rep,name=locked_lnds,json=lockedLnds,proto3" json:"locked_lnds,omitempty"`
}

func (x *UnlockNodeResponse) Reset() {
	*x = UnlockNodeResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[73]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnlockNodeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnlockNodeResponse) ProtoMessage() {}

func (x *UnlockNodeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[73]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnlockNodeResponse.ProtoReflect.Descriptor instead.
func (*UnlockNodeResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{73}
}

func (x *UnlockNodeResponse) GetUnlockedLnds() []string {
	if x != nil {
		return x.UnlockedLnds
	}
	return nil
}

func (x *UnlockNodeResponse) GetLockedLnds() []string {
	if x != nil {
		return x.LockedLnds
	}
	return nil
}

type WithdrawRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ticker symbol of the currency to withdraw.
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	// The address to withdraw funds to.
	Destination string `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// The amount to withdraw denominated in satoshis
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// Whether to withdraw all available funds for this currency.
	// If true, the amount field is ignored.
	All bool `protobuf:"varint,4,opt,name=all,proto3" json:"all,omitempty"`
	// The fee to use for the withdrawal transaction denominated in satoshis per byte.
	Fee uint32 `protobuf:"varint,5,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (x *WithdrawRequest) Reset() {
	*x = WithdrawRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[74]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WithdrawRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WithdrawRequest) ProtoMessage() {}

func (x *WithdrawRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[74]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WithdrawRequest.ProtoReflect.Descriptor instead.
func (*WithdrawRequest) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{74}
}

func (x *WithdrawRequest) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *WithdrawRequest) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *WithdrawRequest) GetAmount() uint64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *WithdrawRequest) GetAll() bool {
	if x != nil {
		return x.All
	}
	return false
}

func (x *WithdrawRequest) GetFee() uint32 {
	if x != nil {
		return x.Fee
	}
	return 0
}

type WithdrawResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The id of the withdrawal transaction.
	TransactionId string `protobuf:"bytes,1,opt,name=transaction_id,proto3" json:"transaction_id,omitempty"`
}

func (x *WithdrawResponse) Reset() {
	*x = WithdrawResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xudrpc_proto_msgTypes[75]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WithdrawResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WithdrawResponse) ProtoMessage() {}

func (x *WithdrawResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xudrpc_proto_msgTypes[75]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WithdrawResponse.ProtoReflect.Descriptor instead.
func (*WithdrawResponse) Descriptor() ([]byte, []int) {
	return file_xudrpc_proto_rawDescGZIP(), []int{75}
}

func (x *WithdrawResponse) GetTransactionId() string {
	if x != nil {
		return x.TransactionId
	}
	return ""
}

var File_xudrpc_proto protoreflect.FileDescriptor

var file_xudrpc_proto_rawDesc = []byte{
	0x0a, 0x0c, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06,
	0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x1a, 0x11, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x15, 0x0a, 0x13, 0x41, 0x64, 0x64,
	0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x5e, 0x0a, 0x0e, 0x41, 0x64, 0x64, 0x50, 0x61, 0x69, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x24, 0x0a, 0x0d, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x62, 0x61, 0x73, 0x65, 0x5f,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x26, 0x0a, 0x0e, 0x71, 0x75, 0x6f, 0x74,
	0x65, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0e, 0x71, 0x75, 0x6f, 0x74, 0x65, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x22, 0x11, 0x0a, 0x0f, 0x41, 0x64, 0x64, 0x50, 0x61, 0x69, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0xb7, 0x02, 0x0a, 0x07, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12,
	0x24, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x61,
	0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x28, 0x0a, 0x0f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
	0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f,
	0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12,
	0x38, 0x0a, 0x17, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x17, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x3a, 0x0a, 0x18, 0x69, 0x6e, 0x61,
	0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x62, 0x61,
	0x6c, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x18, 0x69, 0x6e, 0x61,
	0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x62, 0x61,
	0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x26, 0x0a, 0x0e, 0x77, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x5f,
	0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e, 0x77,
	0x61, 0x6c, 0x6c, 0x65, 0x74, 0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x3e, 0x0a,
	0x1a, 0x75, 0x6e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x65, 0x64, 0x5f, 0x77, 0x61, 0x6c,
	0x6c, 0x65, 0x74, 0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x1a, 0x75, 0x6e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x65, 0x64, 0x5f, 0x77,
	0x61, 0x6c, 0x6c, 0x65, 0x74, 0x5f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x22, 0x36, 0x0a,
	0x0a, 0x42, 0x61, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x0f, 0x6e,
	0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74,
	0x69, 0x66, 0x69, 0x65, 0x72, 0x22, 0x0d, 0x0a, 0x0b, 0x42, 0x61, 0x6e, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x37, 0x0a, 0x05, 0x43, 0x68, 0x61, 0x69, 0x6e, 0x12, 0x14, 0x0a,
	0x05, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x22, 0x70, 0x0a,
	0x08, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x63, 0x74,
	0x69, 0x76, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x76,
	0x65, 0x12, 0x1a, 0x0a, 0x08, 0x69, 0x6e, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x08, 0x69, 0x6e, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x18, 0x0a,
	0x07, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07,
	0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6c, 0x6f, 0x73, 0x65,
	0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x22,
	0xab, 0x01, 0x0a, 0x13, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f,
	0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65,
	0x72, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x14, 0x0a,
	0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x66, 0x6f,
	0x72, 0x63, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x40, 0x0a,
	0x14, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0f,
	0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x73, 0x22,
	0x2c, 0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x1a, 0x0a, 0x08, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x75, 0x72, 0x69, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x75, 0x72, 0x69, 0x22, 0x11, 0x0a,
	0x0f, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x2f, 0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x22, 0x64, 0x0a, 0x12, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x73, 0x65, 0x65, 0x64, 0x5f,
	0x6d, 0x6e, 0x65, 0x6d, 0x6f, 0x6e, 0x69, 0x63, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c,
	0x73, 0x65, 0x65, 0x64, 0x4d, 0x6e, 0x65, 0x6d, 0x6f, 0x6e, 0x69, 0x63, 0x12, 0x29, 0x0a, 0x10,
	0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x5f, 0x6c, 0x6e, 0x64, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0f, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x69,
	0x7a, 0x65, 0x64, 0x4c, 0x6e, 0x64, 0x73, 0x22, 0xd7, 0x01, 0x0a, 0x08, 0x43, 0x75, 0x72, 0x72,
	0x65, 0x6e, 0x63, 0x79, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x12, 0x3d, 0x0a, 0x0b, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x43,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x2e, 0x53, 0x77, 0x61, 0x70, 0x43, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x52, 0x0b, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x12,
	0x24, 0x0a, 0x0d, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x26, 0x0a, 0x0e, 0x64, 0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c,
	0x5f, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x64,
	0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x5f, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x22, 0x22, 0x0a,
	0x0a, 0x53, 0x77, 0x61, 0x70, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x07, 0x0a, 0x03, 0x4c,
	0x4e, 0x44, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x58, 0x54, 0x10,
	0x02, 0x22, 0x2c, 0x0a, 0x0e, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x22,
	0x2b, 0x0a, 0x0f, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x40, 0x0a, 0x14,
	0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65,
	0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x6e,
	0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x22, 0x35,
	0x0a, 0x15, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x75, 0x6d, 0x5f, 0x6e,
	0x6f, 0x64, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6e, 0x75, 0x6d, 0x5f,
	0x6e, 0x6f, 0x64, 0x65, 0x73, 0x22, 0x8a, 0x01, 0x0a, 0x12, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
	0x65, 0x53, 0x77, 0x61, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x69, 0x72,
	0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f,
	0x69, 0x64, 0x12, 0x22, 0x0a, 0x0c, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b,
	0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x70,
	0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x22, 0x2f, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x63, 0x79, 0x22, 0xa6, 0x01, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e,
	0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x42, 0x0a, 0x08, 0x62, 0x61,
	0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x78,
	0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x1a, 0x4c,
	0x0a, 0x0d, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
	0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65,
	0x79, 0x12, 0x25, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0f, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63,
	0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x10, 0x0a, 0x0e,
	0x47, 0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xda,
	0x03, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x0c,
	0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79,
	0x12, 0x12, 0x0a, 0x04, 0x75, 0x72, 0x69, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04,
	0x75, 0x72, 0x69, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x75, 0x6d, 0x5f, 0x70, 0x65, 0x65, 0x72,
	0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6e, 0x75, 0x6d, 0x5f, 0x70, 0x65, 0x65,
	0x72, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x75, 0x6d, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x73, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6e, 0x75, 0x6d, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x73,
	0x12, 0x2b, 0x0a, 0x06, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73,
	0x43, 0x6f, 0x75, 0x6e, 0x74, 0x52, 0x06, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x12, 0x32, 0x0a,
	0x03, 0x6c, 0x6e, 0x64, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x78, 0x75, 0x64,
	0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x2e, 0x4c, 0x6e, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x03, 0x6c, 0x6e,
	0x64, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x12, 0x30, 0x0a, 0x13, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x77, 0x61,
	0x70, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x09, 0x52, 0x13,
	0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x68, 0x61, 0x73,
	0x68, 0x65, 0x73, 0x12, 0x2d, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x78, 0x74, 0x18, 0x0c,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x6f,
	0x6e, 0x6e, 0x65, 0x78, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
	0x78, 0x74, 0x1a, 0x47, 0x0a, 0x08, 0x4c, 0x6e, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x25, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x0f, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x3e, 0x0a, 0x12, 0x47,
	0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x28, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69,
	0x66, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x6e, 0x6f, 0x64, 0x65,
	0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x22, 0x52, 0x0a, 0x13, 0x47,
	0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x23, 0x0a, 0x0f, 0x72, 0x65, 0x70, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x53, 0x63, 0x6f, 0x72, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x11, 0x52, 0x0a, 0x72, 0x65, 0x70,
	0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x62, 0x61, 0x6e, 0x6e, 0x65,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x22,
	0x17, 0x0a, 0x15, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x69, 0x65,
	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x4a, 0x0a, 0x16, 0x4c, 0x69, 0x73, 0x74,
	0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x30, 0x0a, 0x0a, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e,
	0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x52, 0x0a, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
	0x63, 0x69, 0x65, 0x73, 0x22, 0xca, 0x01, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x72, 0x64,
	0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61,
	0x69, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x69,
	0x72, 0x5f, 0x69, 0x64, 0x12, 0x35, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69, 0x73,
	0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x4f,
	0x77, 0x6e, 0x65, 0x72, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x6c,
	0x69, 0x6d, 0x69, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69,
	0x74, 0x12, 0x28, 0x0a, 0x0f, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x61, 0x6c, 0x69,
	0x61, 0x73, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x69, 0x6e, 0x63, 0x6c,
	0x75, 0x64, 0x65, 0x5f, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x65, 0x73, 0x22, 0x24, 0x0a, 0x05, 0x4f,
	0x77, 0x6e, 0x65, 0x72, 0x12, 0x08, 0x0a, 0x04, 0x42, 0x4f, 0x54, 0x48, 0x10, 0x00, 0x12, 0x07,
	0x0a, 0x03, 0x4f, 0x57, 0x4e, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x50, 0x45, 0x45, 0x52, 0x10,
	0x02, 0x22, 0x9f, 0x01, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3e, 0x0a, 0x06, 0x6f, 0x72, 0x64, 0x65,
	0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
	0x52, 0x06, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x1a, 0x49, 0x0a, 0x0b, 0x4f, 0x72, 0x64, 0x65,
	0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x24, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
	0x02, 0x38, 0x01, 0x22, 0x12, 0x0a, 0x10, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x61, 0x69, 0x72, 0x73,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x29, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x50,
	0x61, 0x69, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x70, 0x61, 0x69, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x70, 0x61, 0x69,
	0x72, 0x73, 0x22, 0x12, 0x0a, 0x10, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x65, 0x65, 0x72, 0x73, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x37, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x65,
	0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x22, 0x0a, 0x05, 0x70,
	0x65, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x78, 0x75, 0x64,
	0x72, 0x70, 0x63, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x52, 0x05, 0x70, 0x65, 0x65, 0x72, 0x73, 0x22,
	0xdc, 0x01, 0x0a, 0x07, 0x4c, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x2c, 0x0a, 0x08, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x43,
	0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x52, 0x08, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
	0x73, 0x12, 0x25, 0x0a, 0x06, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x68, 0x61, 0x69, 0x6e,
	0x52, 0x06, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x62, 0x6c, 0x6f, 0x63,
	0x6b, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x62,
	0x6c, 0x6f, 0x63, 0x6b, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x72,
	0x69, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x75, 0x72, 0x69, 0x73, 0x12, 0x18,
	0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x6c, 0x69, 0x61,
	0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x22, 0x4a,
	0x0a, 0x0e, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72,
	0x12, 0x22, 0x0a, 0x0c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x75, 0x62,
	0x5f, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x22, 0x94, 0x01, 0x0a, 0x12, 0x4f,
	0x70, 0x65, 0x6e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x28, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69,
	0x66, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x6e, 0x6f, 0x64, 0x65,
	0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x63,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12,
	0x20, 0x0a, 0x0b, 0x70, 0x75, 0x73, 0x68, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x70, 0x75, 0x73, 0x68, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
	0x74, 0x22, 0x3d, 0x0a, 0x13, 0x4f, 0x70, 0x65, 0x6e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64,
	0x22, 0xc0, 0x02, 0x0a, 0x05, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x70, 0x72,
	0x69, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65,
	0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x18, 0x0a, 0x07,
	0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70,
	0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x40, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69,
	0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x16, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x65,
	0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64,
	0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61,
	0x6c, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x61,
	0x6c, 0x5f, 0x69, 0x64, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f,
	0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x64, 0x5f, 0x61, 0x74, 0x12, 0x25, 0x0a, 0x04, 0x73, 0x69, 0x64, 0x65, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x11, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65,
	0x72, 0x53, 0x69, 0x64, 0x65, 0x52, 0x04, 0x73, 0x69, 0x64, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x69,
	0x73, 0x5f, 0x6f, 0x77, 0x6e, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x0c, 0x69, 0x73, 0x5f, 0x6f, 0x77, 0x6e, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x12,
	0x12, 0x0a, 0x04, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x68,
	0x6f, 0x6c, 0x64, 0x22, 0xa0, 0x01, 0x0a, 0x0c, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x6d,
	0x6f, 0x76, 0x61, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79,
	0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x6f, 0x72,
	0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6f, 0x72,
	0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f,
	0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f,
	0x69, 0x64, 0x12, 0x22, 0x0a, 0x0c, 0x69, 0x73, 0x5f, 0x6f, 0x77, 0x6e, 0x5f, 0x6f, 0x72, 0x64,
	0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x69, 0x73, 0x5f, 0x6f, 0x77, 0x6e,
	0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x68, 0x0a, 0x06, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73,
	0x12, 0x2d, 0x0a, 0x0a, 0x62, 0x75, 0x79, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x52, 0x0a, 0x62, 0x75, 0x79, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x12,
	0x2f, 0x0a, 0x0b, 0x73, 0x65, 0x6c, 0x6c, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x52, 0x0b, 0x73, 0x65, 0x6c, 0x6c, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73,
	0x22, 0x33, 0x0a, 0x0b, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12,
	0x12, 0x0a, 0x04, 0x70, 0x65, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x70,
	0x65, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6f, 0x77, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x03, 0x6f, 0x77, 0x6e, 0x22, 0x82, 0x01, 0x0a, 0x0b, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x55,
	0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x25, 0x0a, 0x05, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x48, 0x00, 0x52, 0x05, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x3c, 0x0a, 0x0d,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64,
	0x65, 0x72, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c, 0x48, 0x00, 0x52, 0x0d, 0x6f, 0x72, 0x64,
	0x65, 0x72, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c, 0x42, 0x0e, 0x0a, 0x0c, 0x6f, 0x72,
	0x64, 0x65, 0x72, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x22, 0xdb, 0x02, 0x0a, 0x04, 0x50,
	0x65, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x22, 0x0a,
	0x0c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65,
	0x79, 0x12, 0x40, 0x0a, 0x0c, 0x6c, 0x6e, 0x64, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79,
	0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63,
	0x2e, 0x50, 0x65, 0x65, 0x72, 0x2e, 0x4c, 0x6e, 0x64, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x73,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0c, 0x6c, 0x6e, 0x64, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b,
	0x65, 0x79, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x69, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x14, 0x0a,
	0x05, 0x70, 0x61, 0x69, 0x72, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x70, 0x61,
	0x69, 0x72, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x78, 0x75, 0x64, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x78, 0x75, 0x64, 0x5f, 0x76, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x2c, 0x0a, 0x11, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73,
	0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x11, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
	0x74, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x18, 0x09, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x1a, 0x3d, 0x0a, 0x0f, 0x4c, 0x6e, 0x64,
	0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x80, 0x02, 0x0a, 0x11, 0x50, 0x6c, 0x61,
	0x63, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14,
	0x0a, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x70,
	0x72, 0x69, 0x63, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79,
	0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x6f, 0x72,
	0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6f, 0x72,
	0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x25, 0x0a, 0x04, 0x73, 0x69, 0x64, 0x65, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x11, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x53, 0x69, 0x64, 0x65, 0x52, 0x04, 0x73, 0x69, 0x64, 0x65, 0x12, 0x2a, 0x0a,
	0x10, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69,
	0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65,
	0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x30, 0x0a, 0x13, 0x69, 0x6d, 0x6d,
	0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x5f, 0x6f, 0x72, 0x5f, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x69, 0x6d, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74,
	0x65, 0x5f, 0x6f, 0x72, 0x5f, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x22, 0x80, 0x02, 0x0a, 0x12,
	0x50, 0x6c, 0x61, 0x63, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x39, 0x0a, 0x10, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x6d,
	0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78,
	0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x10, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x12, 0x3b, 0x0a,
	0x0e, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53,
	0x77, 0x61, 0x70, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x52, 0x0e, 0x73, 0x77, 0x61, 0x70,
	0x5f, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x37, 0x0a, 0x0f, 0x72, 0x65,
	0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64,
	0x65, 0x72, 0x52, 0x0f, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x6f, 0x72,
	0x64, 0x65, 0x72, 0x12, 0x39, 0x0a, 0x0d, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x66, 0x61, 0x69, 0x6c,
	0x75, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x78, 0x75, 0x64,
	0x72, 0x70, 0x63, 0x2e, 0x53, 0x77, 0x61, 0x70, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x52,
	0x0d, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x22, 0xf2,
	0x01, 0x0a, 0x0f, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x12, 0x25, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x48, 0x00, 0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x39, 0x0a, 0x0c, 0x73, 0x77, 0x61,
	0x70, 0x5f, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x77, 0x61, 0x70, 0x53, 0x75, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x48, 0x00, 0x52, 0x0c, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x75, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x12, 0x39, 0x0a, 0x0f, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e,
	0x67, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
	0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0f,
	0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x12,
	0x39, 0x0a, 0x0c, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53,
	0x77, 0x61, 0x70, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x48, 0x00, 0x52, 0x0c, 0x73, 0x77,
	0x61, 0x70, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x42, 0x07, 0x0a, 0x05, 0x65, 0x76,
	0x65, 0x6e, 0x74, 0x22, 0x6f, 0x0a, 0x0b, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x78, 0x74, 0x49, 0x6e,
	0x66, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x14,
	0x0a, 0x05, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x22, 0x33, 0x0a, 0x15, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x75,
	0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a,
	0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x22, 0x18, 0x0a, 0x16, 0x52, 0x65, 0x6d,
	0x6f, 0x76, 0x65, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x4c, 0x0a, 0x12, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4f, 0x72, 0x64,
	0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x6f, 0x72, 0x64,
	0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6f, 0x72, 0x64,
	0x65, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74,
	0x79, 0x22, 0x35, 0x0a, 0x13, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1e, 0x0a, 0x10, 0x71, 0x75, 0x61, 0x6e,
	0x74, 0x69, 0x74, 0x79, 0x5f, 0x6f, 0x6e, 0x5f, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x04, 0x68, 0x6f, 0x6c, 0x64, 0x22, 0x2d, 0x0a, 0x11, 0x52, 0x65, 0x6d, 0x6f,
	0x76, 0x65, 0x50, 0x61, 0x69, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a,
	0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x22, 0x14, 0x0a, 0x12, 0x52, 0x65, 0x6d, 0x6f, 0x76,
	0x65, 0x50, 0x61, 0x69, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x84, 0x02,
	0x0a, 0x12, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x73, 0x65, 0x65, 0x64, 0x5f, 0x6d, 0x6e, 0x65,
	0x6d, 0x6f, 0x6e, 0x69, 0x63, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x73, 0x65, 0x65,
	0x64, 0x4d, 0x6e, 0x65, 0x6d, 0x6f, 0x6e, 0x69, 0x63, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73,
	0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73,
	0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x4b, 0x0a, 0x0b, 0x6c, 0x6e, 0x64, 0x5f, 0x62, 0x61, 0x63,
	0x6b, 0x75, 0x70, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x78, 0x75, 0x64,
	0x72, 0x70, 0x63, 0x2e, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x4c, 0x6e, 0x64, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x6c, 0x6e, 0x64, 0x42, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x78, 0x75, 0x64, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61,
	0x73, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0b, 0x78, 0x75, 0x64, 0x44, 0x61, 0x74,
	0x61, 0x62, 0x61, 0x73, 0x65, 0x1a, 0x3d, 0x0a, 0x0f, 0x4c, 0x6e, 0x64, 0x42, 0x61, 0x63, 0x6b,
	0x75, 0x70, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x3a, 0x02, 0x38, 0x01, 0x22, 0x3a, 0x0a, 0x13, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x4e,
	0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x72,
	0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x5f, 0x6c, 0x6e, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x4c, 0x6e, 0x64, 0x73,
	0x22, 0x11, 0x0a, 0x0f, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x22, 0x12, 0x0a, 0x10, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x34, 0x0a, 0x16, 0x53, 0x75, 0x62, 0x73, 0x63,
	0x72, 0x69, 0x62, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x1a, 0x0a, 0x08, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x08, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x22, 0x1f, 0x0a,
	0x1d, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x53, 0x77, 0x61, 0x70, 0x73, 0x41,
	0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x3d,
	0x0a, 0x15, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x53, 0x77, 0x61, 0x70, 0x73,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x24, 0x0a, 0x0d, 0x69, 0x6e, 0x63, 0x6c, 0x75,
	0x64, 0x65, 0x5f, 0x74, 0x61, 0x6b, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d,
	0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x74, 0x61, 0x6b, 0x65, 0x72, 0x22, 0xfd, 0x02,
	0x0a, 0x0c, 0x53, 0x77, 0x61, 0x70, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x12, 0x19,
	0x0a, 0x08, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x6f, 0x63,
	0x61, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x63,
	0x61, 0x6c, 0x5f, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x12,
	0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x70,
	0x72, 0x69, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x70, 0x72, 0x69, 0x63,
	0x65, 0x12, 0x22, 0x0a, 0x0c, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65,
	0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x70, 0x75,
	0x62, 0x5f, 0x6b, 0x65, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x12, 0x2a, 0x0a,
	0x10, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x69, 0x6e,
	0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x10, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f,
	0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x69, 0x6e, 0x67, 0x12, 0x26, 0x0a, 0x0e, 0x61, 0x6d, 0x6f,
	0x75, 0x6e, 0x74, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x0e, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e,
	0x67, 0x12, 0x2e, 0x0a, 0x12, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x72, 0x65,
	0x63, 0x65, 0x69, 0x76, 0x69, 0x6e, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x63,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x69, 0x6e,
	0x67, 0x12, 0x2a, 0x0a, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x73, 0x65,
	0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x22, 0xab, 0x01,
	0x0a, 0x0b, 0x53, 0x77, 0x61, 0x70, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x1a, 0x0a,
	0x08, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x08, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x69,
	0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x69, 0x72,
	0x5f, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12,
	0x22, 0x0a, 0x0c, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x70, 0x75, 0x62, 0x5f,
	0x6b, 0x65, 0x79, 0x12, 0x26, 0x0a, 0x0e, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x5f, 0x72,
	0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x66, 0x61, 0x69,
	0x6c, 0x75, 0x72, 0x65, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x22, 0xae, 0x03, 0x0a, 0x0b,
	0x53, 0x77, 0x61, 0x70, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x19, 0x0a, 0x08, 0x6f,
	0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6f,
	0x72, 0x64, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f,
	0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f,
	0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08,
	0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08,
	0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x5f, 0x68, 0x61,
	0x73, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x5f, 0x68, 0x61, 0x73, 0x68,
	0x12, 0x28, 0x0a, 0x0f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69,
	0x76, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
	0x74, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x12, 0x20, 0x0a, 0x0b, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x0b, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x12, 0x22, 0x0a, 0x0c,
	0x70, 0x65, 0x65, 0x72, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x0a, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0c, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79,
	0x12, 0x20, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0c,
	0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f,
	0x6c, 0x65, 0x12, 0x2c, 0x0a, 0x11, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x72,
	0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x63,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64,
	0x12, 0x24, 0x0a, 0x0d, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x73, 0x65, 0x6e,
	0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63,
	0x79, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x72, 0x5f, 0x70, 0x72, 0x65, 0x69,
	0x6d, 0x61, 0x67, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x72, 0x5f, 0x70, 0x72,
	0x65, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18,
	0x0f, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65, 0x22, 0xf4, 0x02, 0x0a,
	0x05, 0x54, 0x72, 0x61, 0x64, 0x65, 0x12, 0x2f, 0x0a, 0x0b, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x5f,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75,
	0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x0b, 0x6d, 0x61, 0x6b, 0x65,
	0x72, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x2f, 0x0a, 0x0b, 0x74, 0x61, 0x6b, 0x65, 0x72,
	0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78,
	0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x0b, 0x74, 0x61, 0x6b,
	0x65, 0x72, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x5f, 0x68, 0x61,
	0x73, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x5f, 0x68, 0x61, 0x73, 0x68,
	0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x18, 0x0a, 0x07,
	0x70, 0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70,
	0x61, 0x69, 0x72, 0x5f, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x70, 0x72, 0x69, 0x63, 0x65, 0x12, 0x20, 0x0a, 0x04,
	0x72, 0x6f, 0x6c, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0c, 0x2e, 0x78, 0x75, 0x64,
	0x72, 0x70, 0x63, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12, 0x20,
	0x0a, 0x0b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74,
	0x12, 0x25, 0x0a, 0x04, 0x73, 0x69, 0x64, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x11,
	0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x69, 0x64,
	0x65, 0x52, 0x04, 0x73, 0x69, 0x64, 0x65, 0x12, 0x3a, 0x0a, 0x0c, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x65, 0x72, 0x70, 0x61, 0x72, 0x74, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x65, 0x6e, 0x74,
	0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x0c, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x61,
	0x72, 0x74, 0x79, 0x22, 0x2b, 0x0a, 0x13, 0x54, 0x72, 0x61, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74,
	0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69,
	0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74,
	0x22, 0x3d, 0x0a, 0x14, 0x54, 0x72, 0x61, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x25, 0x0a, 0x06, 0x74, 0x72, 0x61, 0x64,
	0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x54, 0x72, 0x61, 0x64, 0x65, 0x52, 0x06, 0x74, 0x72, 0x61, 0x64, 0x65, 0x73, 0x22,
	0x43, 0x0a, 0x0d, 0x54, 0x72, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73,
	0x12, 0x19, 0x0a, 0x07, 0x4d, 0x61, 0x78, 0x53, 0x65, 0x6c, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x65, 0x6c, 0x6c, 0x12, 0x17, 0x0a, 0x06, 0x4d,
	0x61, 0x78, 0x42, 0x75, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x6d, 0x61, 0x78,
	0x5f, 0x62, 0x75, 0x79, 0x22, 0x32, 0x0a, 0x14, 0x54, 0x72, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x4c,
	0x69, 0x6d, 0x69, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x22, 0xac, 0x01, 0x0a, 0x15, 0x54, 0x72, 0x61,
	0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x41, 0x0a, 0x06, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x29, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x54, 0x72, 0x61, 0x64,
	0x69, 0x6e, 0x67, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x2e, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x6c,
	0x69, 0x6d, 0x69, 0x74, 0x73, 0x1a, 0x50, 0x0a, 0x0b, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2b, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x54,
	0x72, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x56, 0x0a, 0x0c, 0x55, 0x6e, 0x62, 0x61, 0x6e,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f,
	0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65,
	0x72, 0x12, 0x1c, 0x0a, 0x09, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x22,
	0x0f, 0x0a, 0x0d, 0x55, 0x6e, 0x62, 0x61, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x2f, 0x0a, 0x11, 0x55, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x22, 0x5a, 0x0a, 0x12, 0x55, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x6f, 0x64, 0x65, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x75, 0x6e, 0x6c, 0x6f, 0x63,
	0x6b, 0x65, 0x64, 0x5f, 0x6c, 0x6e, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c,
	0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x4c, 0x6e, 0x64, 0x73, 0x12, 0x1f, 0x0a, 0x0b,
	0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x5f, 0x6c, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x0a, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x4c, 0x6e, 0x64, 0x73, 0x22, 0x8b, 0x01,
	0x0a, 0x0f, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x20, 0x0a,
	0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
	0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x61, 0x6c, 0x6c, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x61, 0x6c, 0x6c, 0x12, 0x10, 0x0a, 0x03, 0x66, 0x65, 0x65,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x66, 0x65, 0x65, 0x22, 0x3a, 0x0a, 0x10, 0x57,
	0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x26, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x2a, 0x28, 0x0a, 0x09, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x53, 0x69, 0x64, 0x65, 0x12, 0x07, 0x0a, 0x03, 0x42, 0x55, 0x59, 0x10, 0x00, 0x12, 0x08, 0x0a,
	0x04, 0x53, 0x45, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x42, 0x4f, 0x54, 0x48, 0x10,
	0x02, 0x2a, 0x2a, 0x0a, 0x04, 0x52, 0x6f, 0x6c, 0x65, 0x12, 0x09, 0x0a, 0x05, 0x54, 0x41, 0x4b,
	0x45, 0x52, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x4b, 0x45, 0x52, 0x10, 0x01, 0x12,
	0x0c, 0x0a, 0x08, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x10, 0x02, 0x32, 0xe1, 0x01,
	0x0a, 0x07, 0x58, 0x75, 0x64, 0x49, 0x6e, 0x69, 0x74, 0x12, 0x45, 0x0a, 0x0a, 0x43, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63,
	0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x72, 0x65, 0x61,
	0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x48, 0x0a, 0x0b, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12,
	0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65,
	0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x78, 0x75,
	0x64, 0x72, 0x70, 0x63, 0x2e, 0x52, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x45, 0x0a, 0x0a, 0x55, 0x6e,
	0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x55, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x55, 0x6e, 0x6c,
	0x6f, 0x63, 0x6b, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x00, 0x32, 0xb9, 0x16, 0x0a, 0x03, 0x58, 0x75, 0x64, 0x12, 0x58, 0x0a, 0x0b, 0x41, 0x64, 0x64,
	0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x10, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x1a, 0x1b, 0x2e, 0x78, 0x75, 0x64,
	0x72, 0x70, 0x63, 0x2e, 0x41, 0x64, 0x64, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x14, 0x22,
	0x0f, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x64, 0x64, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x3a, 0x01, 0x2a, 0x12, 0x52, 0x0a, 0x07, 0x41, 0x64, 0x64, 0x50, 0x61, 0x69, 0x72, 0x12, 0x16,
	0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x64, 0x64, 0x50, 0x61, 0x69, 0x72, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e,
	0x41, 0x64, 0x64, 0x50, 0x61, 0x69, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x16, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x10, 0x22, 0x0b, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x64, 0x64,
	0x70, 0x61, 0x69, 0x72, 0x3a, 0x01, 0x2a, 0x12, 0x42, 0x0a, 0x03, 0x42, 0x61, 0x6e, 0x12, 0x12,
	0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x42, 0x61, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x42, 0x61, 0x6e, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x12, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0c, 0x22,
	0x07, 0x2f, 0x76, 0x31, 0x2f, 0x62, 0x61, 0x6e, 0x3a, 0x01, 0x2a, 0x12, 0x63, 0x0a, 0x0c, 0x43,
	0x6c, 0x6f, 0x73, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x1b, 0x2e, 0x78, 0x75,
	0x64, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x18, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x12, 0x22, 0x10,
	0x2f, 0x76, 0x31, 0x2f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
	0x12, 0x52, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x16, 0x2e, 0x78, 0x75,
	0x64, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x6f, 0x6e,
	0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x16, 0x82, 0xd3,
	0xe4, 0x93, 0x02, 0x10, 0x22, 0x0b, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
	0x74, 0x3a, 0x01, 0x2a, 0x12, 0x5e, 0x0a, 0x0d, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x44, 0x65,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x12, 0x16, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x44,
	0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e,
	0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1c, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x16, 0x22, 0x11,
	0x2f, 0x76, 0x31, 0x2f, 0x77, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x3a, 0x01, 0x2a, 0x12, 0x6a, 0x0a, 0x0d, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
	0x4e, 0x6f, 0x64, 0x65, 0x73, 0x12, 0x1c, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x44,
	0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x44, 0x69, 0x73,
	0x63, 0x6f, 0x76, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x1c, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x16, 0x22, 0x11, 0x2f, 0x76, 0x31, 0x2f,
	0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x3a, 0x01, 0x2a,
	0x12, 0x58, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x19,
	0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e,
	0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72,
	0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x13, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0d, 0x12, 0x0b, 0x2f,
	0x76, 0x31, 0x2f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x4c, 0x0a, 0x07, 0x47, 0x65,
	0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x16, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x47,
	0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e,
	0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x10, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0a, 0x12, 0x08,
	0x2f, 0x76, 0x31, 0x2f, 0x69, 0x6e, 0x66, 0x6f, 0x12, 0x5c, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x4e,
	0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63,
	0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74,
	0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x14, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0e, 0x12, 0x0c, 0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f,
	0x64, 0x65, 0x69, 0x6e, 0x66, 0x6f, 0x12, 0x57, 0x0a, 0x0a, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x73, 0x12, 0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69,
	0x73, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x72, 0x64,
	0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x12, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x0c, 0x12, 0x0a, 0x2f, 0x76, 0x31, 0x2f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x12,
	0x67, 0x0a, 0x0e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x69, 0x65,
	0x73, 0x12, 0x1d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x1e, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x75,
	0x72, 0x72, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x16, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x75,
	0x72, 0x72, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73, 0x12, 0x53, 0x0a, 0x09, 0x4c, 0x69, 0x73, 0x74,
	0x50, 0x61, 0x69, 0x72, 0x73, 0x12, 0x18, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c,
	0x69, 0x73, 0x74, 0x50, 0x61, 0x69, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x61, 0x69,
	0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x11, 0x82, 0xd3, 0xe4, 0x93,
	0x02, 0x0b, 0x12, 0x09, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x61, 0x69, 0x72, 0x73, 0x12, 0x53, 0x0a,
	0x09, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x65, 0x65, 0x72, 0x73, 0x12, 0x18, 0x2e, 0x78, 0x75, 0x64,
	0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x65, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4c, 0x69,
	0x73, 0x74, 0x50, 0x65, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x11, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0b, 0x12, 0x09, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x65, 0x65,
	0x72, 0x73, 0x12, 0x5f, 0x0a, 0x0b, 0x4f, 0x70, 0x65, 0x6e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x12, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x70, 0x65, 0x6e, 0x43,
	0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e,
	0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f, 0x70, 0x65, 0x6e, 0x43, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x17, 0x82, 0xd3, 0xe4, 0x93,
	0x02, 0x11, 0x22, 0x0f, 0x2f, 0x76, 0x31, 0x2f, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x12, 0x5d, 0x0a, 0x0a, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x4f, 0x72, 0x64, 0x65,
	0x72, 0x12, 0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x50, 0x6c, 0x61, 0x63, 0x65,
	0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x78,
	0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x22, 0x19, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x13, 0x22, 0x0e, 0x2f,
	0x76, 0x31, 0x2f, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x3a, 0x01, 0x2a,
	0x30, 0x01, 0x12, 0x66, 0x0a, 0x0e, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x53, 0x79, 0x6e, 0x63, 0x12, 0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x50, 0x6c,
	0x61, 0x63, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1d, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x17, 0x22, 0x12, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x6f, 0x72,
	0x64, 0x65, 0x72, 0x73, 0x79, 0x6e, 0x63, 0x3a, 0x01, 0x2a, 0x12, 0x5a, 0x0a, 0x0b, 0x45, 0x78,
	0x65, 0x63, 0x75, 0x74, 0x65, 0x53, 0x77, 0x61, 0x70, 0x12, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72,
	0x70, 0x63, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x53, 0x77, 0x61, 0x70, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53,
	0x77, 0x61, 0x70, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0x1a, 0x82, 0xd3, 0xe4, 0x93,
	0x02, 0x14, 0x22, 0x0f, 0x2f, 0x76, 0x31, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x73,
	0x77, 0x61, 0x70, 0x3a, 0x01, 0x2a, 0x12, 0x6e, 0x0a, 0x0e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65,
	0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x1d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63,
	0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1d, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x17, 0x22,
	0x12, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x63, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x63, 0x79, 0x3a, 0x01, 0x2a, 0x12, 0x62, 0x0a, 0x0b, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65,
	0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x52,
	0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x1b, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76,
	0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1a,
	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x14, 0x22, 0x0f, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x65, 0x6d, 0x6f,
	0x76, 0x65, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x3a, 0x01, 0x2a, 0x12, 0x5e, 0x0a, 0x0a, 0x52, 0x65,
	0x6d, 0x6f, 0x76, 0x65, 0x50, 0x61, 0x69, 0x72, 0x12, 0x19, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70,
	0x63, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x50, 0x61, 0x69, 0x72, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x52, 0x65, 0x6d,
	0x6f, 0x76, 0x65, 0x50, 0x61, 0x69, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x19, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x13, 0x22, 0x0e, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x65, 0x6d,
	0x6f, 0x76, 0x65, 0x70, 0x61, 0x69, 0x72, 0x3a, 0x01, 0x2a, 0x12, 0x56, 0x0a, 0x08, 0x53, 0x68,
	0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x12, 0x17, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e,
	0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x18, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77,
	0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x17, 0x82, 0xd3, 0xe4, 0x93, 0x02,
	0x11, 0x22, 0x0c, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x3a,
	0x01, 0x2a, 0x12, 0x65, 0x0a, 0x0f, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x4f,
	0x72, 0x64, 0x65, 0x72, 0x73, 0x12, 0x1e, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53,
	0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x4f,
	0x72, 0x64, 0x65, 0x72, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x22, 0x1b, 0x82, 0xd3, 0xe4, 0x93,
	0x02, 0x15, 0x12, 0x13, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62,
	0x65, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x30, 0x01, 0x12, 0x70, 0x0a, 0x15, 0x53, 0x75, 0x62,
	0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x53, 0x77, 0x61, 0x70, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72,
	0x65, 0x73, 0x12, 0x1d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x75, 0x62, 0x73,
	0x63, 0x72, 0x69, 0x62, 0x65, 0x53, 0x77, 0x61, 0x70, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x13, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x77, 0x61, 0x70, 0x46,
	0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x22, 0x21, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1b, 0x12, 0x19,
	0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x77, 0x61,
	0x70, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x30, 0x01, 0x12, 0x62, 0x0a, 0x0e, 0x53,
	0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x53, 0x77, 0x61, 0x70, 0x73, 0x12, 0x1d, 0x2e,
	0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
	0x53, 0x77, 0x61, 0x70, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x78,
	0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x77, 0x61, 0x70, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73,
	0x73, 0x22, 0x1a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x14, 0x12, 0x12, 0x2f, 0x76, 0x31, 0x2f, 0x73,
	0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x77, 0x61, 0x70, 0x73, 0x30, 0x01, 0x12,
	0x7b, 0x0a, 0x16, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x53, 0x77, 0x61, 0x70,
	0x73, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x12, 0x25, 0x2e, 0x78, 0x75, 0x64, 0x72,
	0x70, 0x63, 0x2e, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x53, 0x77, 0x61, 0x70,
	0x73, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x14, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x77, 0x61, 0x70, 0x41, 0x63,
	0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x22, 0x22, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1c, 0x12, 0x1a,
	0x2f, 0x76, 0x31, 0x2f, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x77, 0x61,
	0x70, 0x73, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x65, 0x64, 0x30, 0x01, 0x12, 0x66, 0x0a, 0x0c,
	0x54, 0x72, 0x61, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x1b, 0x2e, 0x78,
	0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x54, 0x72, 0x61, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f,
	0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x78, 0x75, 0x64, 0x72,
	0x70, 0x63, 0x2e, 0x54, 0x72, 0x61, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x15, 0x22,
	0x10, 0x2f, 0x76, 0x31, 0x2f, 0x74, 0x72, 0x61, 0x64, 0x65, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72,
	0x79, 0x3a, 0x01, 0x2a, 0x12, 0x67, 0x0a, 0x0d, 0x54, 0x72, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x4c,
	0x69, 0x6d, 0x69, 0x74, 0x73, 0x12, 0x1c, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x54,
	0x72, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x54, 0x72, 0x61,
	0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x19, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x13, 0x12, 0x11, 0x2f, 0x76, 0x31, 0x2f,
	0x74, 0x72, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x12, 0x4a, 0x0a,
	0x05, 0x55, 0x6e, 0x62, 0x61, 0x6e, 0x12, 0x14, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e,
	0x55, 0x6e, 0x62, 0x61, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x15, 0x2e, 0x78,
	0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x55, 0x6e, 0x62, 0x61, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x14, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0e, 0x22, 0x09, 0x2f, 0x76, 0x31,
	0x2f, 0x75, 0x6e, 0x62, 0x61, 0x6e, 0x3a, 0x01, 0x2a, 0x12, 0x62, 0x0a, 0x0e, 0x57, 0x61, 0x6c,
	0x6c, 0x65, 0x74, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x12, 0x17, 0x2e, 0x78, 0x75,
	0x64, 0x72, 0x70, 0x63, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x78, 0x75, 0x64, 0x72, 0x70, 0x63, 0x2e, 0x57, 0x69,
	0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1d,
	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x17, 0x22, 0x12, 0x2f, 0x76, 0x31, 0x2f, 0x77, 0x61, 0x6c, 0x6c,
	0x65, 0x74, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x3a, 0x01, 0x2a, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_xudrpc_proto_rawDescOnce sync.Once
	file_xudrpc_proto_rawDescData = file_xudrpc_proto_rawDesc
)

func file_xudrpc_proto_rawDescGZIP() []byte {
	file_xudrpc_proto_rawDescOnce.Do(func() {
		file_xudrpc_proto_rawDescData = protoimpl.X.CompressGZIP(file_xudrpc_proto_rawDescData)
	})
	return file_xudrpc_proto_rawDescData
}

var file_xudrpc_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_xudrpc_proto_msgTypes = make([]protoimpl.MessageInfo, 82)
var file_xudrpc_proto_goTypes = []interface{}{
	(OrderSide)(0),                        // 0: xudrpc.OrderSide
	(Role)(0),                             // 1: xudrpc.Role
	(Currency_SwapClient)(0),              // 2: xudrpc.Currency.SwapClient
	(ListOrdersRequest_Owner)(0),          // 3: xudrpc.ListOrdersRequest.Owner
	(*AddCurrencyResponse)(nil),           // 4: xudrpc.AddCurrencyResponse
	(*AddPairRequest)(nil),                // 5: xudrpc.AddPairRequest
	(*AddPairResponse)(nil),               // 6: xudrpc.AddPairResponse
	(*Balance)(nil),                       // 7: xudrpc.Balance
	(*BanRequest)(nil),                    // 8: xudrpc.BanRequest
	(*BanResponse)(nil),                   // 9: xudrpc.BanResponse
	(*Chain)(nil),                         // 10: xudrpc.Chain
	(*Channels)(nil),                      // 11: xudrpc.Channels
	(*CloseChannelRequest)(nil),           // 12: xudrpc.CloseChannelRequest
	(*CloseChannelResponse)(nil),          // 13: xudrpc.CloseChannelResponse
	(*ConnectRequest)(nil),                // 14: xudrpc.ConnectRequest
	(*ConnectResponse)(nil),               // 15: xudrpc.ConnectResponse
	(*CreateNodeRequest)(nil),             // 16: xudrpc.CreateNodeRequest
	(*CreateNodeResponse)(nil),            // 17: xudrpc.CreateNodeResponse
	(*Currency)(nil),                      // 18: xudrpc.Currency
	(*DepositRequest)(nil),                // 19: xudrpc.DepositRequest
	(*DepositResponse)(nil),               // 20: xudrpc.DepositResponse
	(*DiscoverNodesRequest)(nil),          // 21: xudrpc.DiscoverNodesRequest
	(*DiscoverNodesResponse)(nil),         // 22: xudrpc.DiscoverNodesResponse
	(*ExecuteSwapRequest)(nil),            // 23: xudrpc.ExecuteSwapRequest
	(*GetBalanceRequest)(nil),             // 24: xudrpc.GetBalanceRequest
	(*GetBalanceResponse)(nil),            // 25: xudrpc.GetBalanceResponse
	(*GetInfoRequest)(nil),                // 26: xudrpc.GetInfoRequest
	(*GetInfoResponse)(nil),               // 27: xudrpc.GetInfoResponse
	(*GetNodeInfoRequest)(nil),            // 28: xudrpc.GetNodeInfoRequest
	(*GetNodeInfoResponse)(nil),           // 29: xudrpc.GetNodeInfoResponse
	(*ListCurrenciesRequest)(nil),         // 30: xudrpc.ListCurrenciesRequest
	(*ListCurrenciesResponse)(nil),        // 31: xudrpc.ListCurrenciesResponse
	(*ListOrdersRequest)(nil),             // 32: xudrpc.ListOrdersRequest
	(*ListOrdersResponse)(nil),            // 33: xudrpc.ListOrdersResponse
	(*ListPairsRequest)(nil),              // 34: xudrpc.ListPairsRequest
	(*ListPairsResponse)(nil),             // 35: xudrpc.ListPairsResponse
	(*ListPeersRequest)(nil),              // 36: xudrpc.ListPeersRequest
	(*ListPeersResponse)(nil),             // 37: xudrpc.ListPeersResponse
	(*LndInfo)(nil),                       // 38: xudrpc.LndInfo
	(*NodeIdentifier)(nil),                // 39: xudrpc.NodeIdentifier
	(*OpenChannelRequest)(nil),            // 40: xudrpc.OpenChannelRequest
	(*OpenChannelResponse)(nil),           // 41: xudrpc.OpenChannelResponse
	(*Order)(nil),                         // 42: xudrpc.Order
	(*OrderRemoval)(nil),                  // 43: xudrpc.OrderRemoval
	(*Orders)(nil),                        // 44: xudrpc.Orders
	(*OrdersCount)(nil),                   // 45: xudrpc.OrdersCount
	(*OrderUpdate)(nil),                   // 46: xudrpc.OrderUpdate
	(*Peer)(nil),                          // 47: xudrpc.Peer
	(*PlaceOrderRequest)(nil),             // 48: xudrpc.PlaceOrderRequest
	(*PlaceOrderResponse)(nil),            // 49: xudrpc.PlaceOrderResponse
	(*PlaceOrderEvent)(nil),               // 50: xudrpc.PlaceOrderEvent
	(*ConnextInfo)(nil),                   // 51: xudrpc.ConnextInfo
	(*RemoveCurrencyRequest)(nil),         // 52: xudrpc.RemoveCurrencyRequest
	(*RemoveCurrencyResponse)(nil),        // 53: xudrpc.RemoveCurrencyResponse
	(*RemoveOrderRequest)(nil),            // 54: xudrpc.RemoveOrderRequest
	(*RemoveOrderResponse)(nil),           // 55: xudrpc.RemoveOrderResponse
	(*RemovePairRequest)(nil),             // 56: xudrpc.RemovePairRequest
	(*RemovePairResponse)(nil),            // 57: xudrpc.RemovePairResponse
	(*RestoreNodeRequest)(nil),            // 58: xudrpc.RestoreNodeRequest
	(*RestoreNodeResponse)(nil),           // 59: xudrpc.RestoreNodeResponse
	(*ShutdownRequest)(nil),               // 60: xudrpc.ShutdownRequest
	(*ShutdownResponse)(nil),              // 61: xudrpc.ShutdownResponse
	(*SubscribeOrdersRequest)(nil),        // 62: xudrpc.SubscribeOrdersRequest
	(*SubscribeSwapsAcceptedRequest)(nil), // 63: xudrpc.SubscribeSwapsAcceptedRequest
	(*SubscribeSwapsRequest)(nil),         // 64: xudrpc.SubscribeSwapsRequest
	(*SwapAccepted)(nil),                  // 65: xudrpc.SwapAccepted
	(*SwapFailure)(nil),                   // 66: xudrpc.SwapFailure
	(*SwapSuccess)(nil),                   // 67: xudrpc.SwapSuccess
	(*Trade)(nil),                         // 68: xudrpc.Trade
	(*TradeHistoryRequest)(nil),           // 69: xudrpc.TradeHistoryRequest
	(*TradeHistoryResponse)(nil),          // 70: xudrpc.TradeHistoryResponse
	(*TradingLimits)(nil),                 // 71: xudrpc.TradingLimits
	(*TradingLimitsRequest)(nil),          // 72: xudrpc.TradingLimitsRequest
	(*TradingLimitsResponse)(nil),         // 73: xudrpc.TradingLimitsResponse
	(*UnbanRequest)(nil),                  // 74: xudrpc.UnbanRequest
	(*UnbanResponse)(nil),                 // 75: xudrpc.UnbanResponse
	(*UnlockNodeRequest)(nil),             // 76: xudrpc.UnlockNodeRequest
	(*UnlockNodeResponse)(nil),            // 77: xudrpc.UnlockNodeResponse
	(*WithdrawRequest)(nil),               // 78: xudrpc.WithdrawRequest
	(*WithdrawResponse)(nil),              // 79: xudrpc.WithdrawResponse
	nil,                                   // 80: xudrpc.GetBalanceResponse.BalancesEntry
	nil,                                   // 81: xudrpc.GetInfoResponse.LndEntry
	nil,                                   // 82: xudrpc.ListOrdersResponse.OrdersEntry
	nil,                                   // 83: xudrpc.Peer.LndPubKeysEntry
	nil,                                   // 84: xudrpc.RestoreNodeRequest.LndBackupsEntry
	nil,                                   // 85: xudrpc.TradingLimitsResponse.LimitsEntry
}
var file_xudrpc_proto_depIdxs = []int32{
	2,  // 0: xudrpc.Currency.swap_client:type_name -> xudrpc.Currency.SwapClient
	80, // 1: xudrpc.GetBalanceResponse.balances:type_name -> xudrpc.GetBalanceResponse.BalancesEntry
	45, // 2: xudrpc.GetInfoResponse.orders:type_name -> xudrpc.OrdersCount
	81, // 3: xudrpc.GetInfoResponse.lnd:type_name -> xudrpc.GetInfoResponse.LndEntry
	51, // 4: xudrpc.GetInfoResponse.connext:type_name -> xudrpc.ConnextInfo
	18, // 5: xudrpc.ListCurrenciesResponse.currencies:type_name -> xudrpc.Currency
	3,  // 6: xudrpc.ListOrdersRequest.owner:type_name -> xudrpc.ListOrdersRequest.Owner
	82, // 7: xudrpc.ListOrdersResponse.orders:type_name -> xudrpc.ListOrdersResponse.OrdersEntry
	47, // 8: xudrpc.ListPeersResponse.peers:type_name -> xudrpc.Peer
	11, // 9: xudrpc.LndInfo.channels:type_name -> xudrpc.Channels
	10, // 10: xudrpc.LndInfo.chains:type_name -> xudrpc.Chain
	39, // 11: xudrpc.Order.node_identifier:type_name -> xudrpc.NodeIdentifier
	0,  // 12: xudrpc.Order.side:type_name -> xudrpc.OrderSide
	42, // 13: xudrpc.Orders.buy_orders:type_name -> xudrpc.Order
	42, // 14: xudrpc.Orders.sell_orders:type_name -> xudrpc.Order
	42, // 15: xudrpc.OrderUpdate.order:type_name -> xudrpc.Order
	43, // 16: xudrpc.OrderUpdate.order_removal:type_name -> xudrpc.OrderRemoval
	83, // 17: xudrpc.Peer.lnd_pub_keys:type_name -> xudrpc.Peer.LndPubKeysEntry
	0,  // 18: xudrpc.PlaceOrderRequest.side:type_name -> xudrpc.OrderSide
	42, // 19: xudrpc.PlaceOrderResponse.internal_matches:type_name -> xudrpc.Order
	67, // 20: xudrpc.PlaceOrderResponse.swap_successes:type_name -> xudrpc.SwapSuccess
	42, // 21: xudrpc.PlaceOrderResponse.remaining_order:type_name -> xudrpc.Order
	66, // 22: xudrpc.PlaceOrderResponse.swap_failures:type_name -> xudrpc.SwapFailure
	42, // 23: xudrpc.PlaceOrderEvent.match:type_name -> xudrpc.Order
	67, // 24: xudrpc.PlaceOrderEvent.swap_success:type_name -> xudrpc.SwapSuccess
	42, // 25: xudrpc.PlaceOrderEvent.remaining_order:type_name -> xudrpc.Order
	66, // 26: xudrpc.PlaceOrderEvent.swap_failure:type_name -> xudrpc.SwapFailure
	84, // 27: xudrpc.RestoreNodeRequest.lnd_backups:type_name -> xudrpc.RestoreNodeRequest.LndBackupsEntry
	1,  // 28: xudrpc.SwapSuccess.role:type_name -> xudrpc.Role
	42, // 29: xudrpc.Trade.maker_order:type_name -> xudrpc.Order
	42, // 30: xudrpc.Trade.taker_order:type_name -> xudrpc.Order
	1,  // 31: xudrpc.Trade.role:type_name -> xudrpc.Role
	0,  // 32: xudrpc.Trade.side:type_name -> xudrpc.OrderSide
	39, // 33: xudrpc.Trade.counterparty:type_name -> xudrpc.NodeIdentifier
	68, // 34: xudrpc.TradeHistoryResponse.trades:type_name -> xudrpc.Trade
	85, // 35: xudrpc.TradingLimitsResponse.limits:type_name -> xudrpc.TradingLimitsResponse.LimitsEntry
	7,  // 36: xudrpc.GetBalanceResponse.BalancesEntry.value:type_name -> xudrpc.Balance
	38, // 37: xudrpc.GetInfoResponse.LndEntry.value:type_name -> xudrpc.LndInfo
	44, // 38: xudrpc.ListOrdersResponse.OrdersEntry.value:type_name -> xudrpc.Orders
	71, // 39: xudrpc.TradingLimitsResponse.LimitsEntry.value:type_name -> xudrpc.TradingLimits
	16, // 40: xudrpc.XudInit.CreateNode:input_type -> xudrpc.CreateNodeRequest
	58, // 41: xudrpc.XudInit.RestoreNode:input_type -> xudrpc.RestoreNodeRequest
	76, // 42: xudrpc.XudInit.UnlockNode:input_type -> xudrpc.UnlockNodeRequest
	18, // 43: xudrpc.Xud.AddCurrency:input_type -> xudrpc.Currency
	5,  // 44: xudrpc.Xud.AddPair:input_type -> xudrpc.AddPairRequest
	8,  // 45: xudrpc.Xud.Ban:input_type -> xudrpc.BanRequest
	12, // 46: xudrpc.Xud.CloseChannel:input_type -> xudrpc.CloseChannelRequest
	14, // 47: xudrpc.Xud.Connect:input_type -> xudrpc.ConnectRequest
	19, // 48: xudrpc.Xud.WalletDeposit:input_type -> xudrpc.DepositRequest
	21, // 49: xudrpc.Xud.DiscoverNodes:input_type -> xudrpc.DiscoverNodesRequest
	24, // 50: xudrpc.Xud.GetBalance:input_type -> xudrpc.GetBalanceRequest
	26, // 51: xudrpc.Xud.GetInfo:input_type -> xudrpc.GetInfoRequest
	28, // 52: xudrpc.Xud.GetNodeInfo:input_type -> xudrpc.GetNodeInfoRequest
	32, // 53: xudrpc.Xud.ListOrders:input_type -> xudrpc.ListOrdersRequest
	30, // 54: xudrpc.Xud.ListCurrencies:input_type -> xudrpc.ListCurrenciesRequest
	34, // 55: xudrpc.Xud.ListPairs:input_type -> xudrpc.ListPairsRequest
	36, // 56: xudrpc.Xud.ListPeers:input_type -> xudrpc.ListPeersRequest
	40, // 57: xudrpc.Xud.OpenChannel:input_type -> xudrpc.OpenChannelRequest
	48, // 58: xudrpc.Xud.PlaceOrder:input_type -> xudrpc.PlaceOrderRequest
	48, // 59: xudrpc.Xud.PlaceOrderSync:input_type -> xudrpc.PlaceOrderRequest
	23, // 60: xudrpc.Xud.ExecuteSwap:input_type -> xudrpc.ExecuteSwapRequest
	52, // 61: xudrpc.Xud.RemoveCurrency:input_type -> xudrpc.RemoveCurrencyRequest
	54, // 62: xudrpc.Xud.RemoveOrder:input_type -> xudrpc.RemoveOrderRequest
	56, // 63: xudrpc.Xud.RemovePair:input_type -> xudrpc.RemovePairRequest
	60, // 64: xudrpc.Xud.Shutdown:input_type -> xudrpc.ShutdownRequest
	62, // 65: xudrpc.Xud.SubscribeOrders:input_type -> xudrpc.SubscribeOrdersRequest
	64, // 66: xudrpc.Xud.SubscribeSwapFailures:input_type -> xudrpc.SubscribeSwapsRequest
	64, // 67: xudrpc.Xud.SubscribeSwaps:input_type -> xudrpc.SubscribeSwapsRequest
	63, // 68: xudrpc.Xud.SubscribeSwapsAccepted:input_type -> xudrpc.SubscribeSwapsAcceptedRequest
	69, // 69: xudrpc.Xud.TradeHistory:input_type -> xudrpc.TradeHistoryRequest
	72, // 70: xudrpc.Xud.TradingLimits:input_type -> xudrpc.TradingLimitsRequest
	74, // 71: xudrpc.Xud.Unban:input_type -> xudrpc.UnbanRequest
	78, // 72: xudrpc.Xud.WalletWithdraw:input_type -> xudrpc.WithdrawRequest
	17, // 73: xudrpc.XudInit.CreateNode:output_type -> xudrpc.CreateNodeResponse
	59, // 74: xudrpc.XudInit.RestoreNode:output_type -> xudrpc.RestoreNodeResponse
	77, // 75: xudrpc.XudInit.UnlockNode:output_type -> xudrpc.UnlockNodeResponse
	4,  // 76: xudrpc.Xud.AddCurrency:output_type -> xudrpc.AddCurrencyResponse
	6,  // 77: xudrpc.Xud.AddPair:output_type -> xudrpc.AddPairResponse
	9,  // 78: xudrpc.Xud.Ban:output_type -> xudrpc.BanResponse
	13, // 79: xudrpc.Xud.CloseChannel:output_type -> xudrpc.CloseChannelResponse
	15, // 80: xudrpc.Xud.Connect:output_type -> xudrpc.ConnectResponse
	20, // 81: xudrpc.Xud.WalletDeposit:output_type -> xudrpc.DepositResponse
	22, // 82: xudrpc.Xud.DiscoverNodes:output_type -> xudrpc.DiscoverNodesResponse
	25, // 83: xudrpc.Xud.GetBalance:output_type -> xudrpc.GetBalanceResponse
	27, // 84: xudrpc.Xud.GetInfo:output_type -> xudrpc.GetInfoResponse
	29, // 85: xudrpc.Xud.GetNodeInfo:output_type -> xudrpc.GetNodeInfoResponse
	33, // 86: xudrpc.Xud.ListOrders:output_type -> xudrpc.ListOrdersResponse
	31, // 87: xudrpc.Xud.ListCurrencies:output_type -> xudrpc.ListCurrenciesResponse
	35, // 88: xudrpc.Xud.ListPairs:output_type -> xudrpc.ListPairsResponse
	37, // 89: xudrpc.Xud.ListPeers:output_type -> xudrpc.ListPeersResponse
	41, // 90: xudrpc.Xud.OpenChannel:output_type -> xudrpc.OpenChannelResponse
	50, // 91: xudrpc.Xud.PlaceOrder:output_type -> xudrpc.PlaceOrderEvent
	49, // 92: xudrpc.Xud.PlaceOrderSync:output_type -> xudrpc.PlaceOrderResponse
	67, // 93: xudrpc.Xud.ExecuteSwap:output_type -> xudrpc.SwapSuccess
	53, // 94: xudrpc.Xud.RemoveCurrency:output_type -> xudrpc.RemoveCurrencyResponse
	55, // 95: xudrpc.Xud.RemoveOrder:output_type -> xudrpc.RemoveOrderResponse
	57, // 96: xudrpc.Xud.RemovePair:output_type -> xudrpc.RemovePairResponse
	61, // 97: xudrpc.Xud.Shutdown:output_type -> xudrpc.ShutdownResponse
	46, // 98: xudrpc.Xud.SubscribeOrders:output_type -> xudrpc.OrderUpdate
	66, // 99: xudrpc.Xud.SubscribeSwapFailures:output_type -> xudrpc.SwapFailure
	67, // 100: xudrpc.Xud.SubscribeSwaps:output_type -> xudrpc.SwapSuccess
	65, // 101: xudrpc.Xud.SubscribeSwapsAccepted:output_type -> xudrpc.SwapAccepted
	70, // 102: xudrpc.Xud.TradeHistory:output_type -> xudrpc.TradeHistoryResponse
	73, // 103: xudrpc.Xud.TradingLimits:output_type -> xudrpc.TradingLimitsResponse
	75, // 104: xudrpc.Xud.Unban:output_type -> xudrpc.UnbanResponse
	79, // 105: xudrpc.Xud.WalletWithdraw:output_type -> xudrpc.WithdrawResponse
	73, // [73:106] is the sub-list for method output_type
	40, // [40:73] is the sub-list for method input_type
	40, // [40:40] is the sub-list for extension type_name
	40, // [40:40] is the sub-list for extension extendee
	0,  // [0:40] is the sub-list for field type_name
}

func init() { file_xudrpc_proto_init() }
func file_xudrpc_proto_init() {
	if File_xudrpc_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_xudrpc_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddCurrencyResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddPairRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddPairResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Balance); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BanRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BanResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Chain); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Channels); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CloseChannelRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CloseChannelResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConnectRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConnectResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateNodeRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateNodeResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Currency); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DepositRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DepositResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DiscoverNodesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DiscoverNodesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecuteSwapRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetBalanceRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetBalanceResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetNodeInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetNodeInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListCurrenciesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListCurrenciesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListOrdersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListOrdersResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListPairsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListPairsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListPeersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListPeersResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LndInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NodeIdentifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OpenChannelRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OpenChannelResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Order); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OrderRemoval); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Orders); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OrdersCount); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OrderUpdate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Peer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PlaceOrderRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PlaceOrderResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PlaceOrderEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[47].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConnextInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[48].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveCurrencyRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[49].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveCurrencyResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[50].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveOrderRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[51].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveOrderResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[52].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemovePairRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[53].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemovePairResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[54].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RestoreNodeRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[55].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RestoreNodeResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[56].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ShutdownRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[57].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ShutdownResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[58].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubscribeOrdersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[59].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubscribeSwapsAcceptedRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[60].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubscribeSwapsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[61].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SwapAccepted); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[62].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SwapFailure); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[63].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SwapSuccess); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[64].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Trade); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[65].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TradeHistoryRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[66].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TradeHistoryResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[67].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TradingLimits); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[68].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TradingLimitsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[69].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TradingLimitsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[70].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnbanRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[71].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnbanResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[72].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnlockNodeRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[73].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnlockNodeResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[74].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WithdrawRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xudrpc_proto_msgTypes[75].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WithdrawResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_xudrpc_proto_msgTypes[42].OneofWrappers = []interface{}{
		(*OrderUpdate_Order)(nil),
		(*OrderUpdate_OrderRemoval)(nil),
	}
	file_xudrpc_proto_msgTypes[46].OneofWrappers = []interface{}{
		(*PlaceOrderEvent_Match)(nil),
		(*PlaceOrderEvent_SwapSuccess)(nil),
		(*PlaceOrderEvent_RemainingOrder)(nil),
		(*PlaceOrderEvent_SwapFailure)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_xudrpc_proto_rawDesc,
			NumEnums:      4,
			NumMessages:   82,
			NumExtensions: 0,
			NumServices:   2,
		},
		GoTypes:           file_xudrpc_proto_goTypes,
		DependencyIndexes: file_xudrpc_proto_depIdxs,
		EnumInfos:         file_xudrpc_proto_enumTypes,
		MessageInfos:      file_xudrpc_proto_msgTypes,
	}.Build()
	File_xudrpc_proto = out.File
	file_xudrpc_proto_rawDesc = nil
	file_xudrpc_proto_goTypes = nil
	file_xudrpc_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// XudInitClient is the client API for XudInit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type XudInitClient interface {
	// Creates an xud identity node key and underlying wallets. The node key and
	// wallets are derived from a single seed and encrypted using a single
	// password provided as a parameter to the call.
	// shell: xucli create
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error)
	// Restores an xud instance and underlying wallets from a seed.
	// shell: xucli restore [backup_directory]
	RestoreNode(ctx context.Context, in *RestoreNodeRequest, opts ...grpc.CallOption) (*RestoreNodeResponse, error)
	// Unlocks and decrypts the xud node key and any underlying wallets.
	// shell: xucli unlock
	UnlockNode(ctx context.Context, in *UnlockNodeRequest, opts ...grpc.CallOption) (*UnlockNodeResponse, error)
}

type xudInitClient struct {
	cc grpc.ClientConnInterface
}

func NewXudInitClient(cc grpc.ClientConnInterface) XudInitClient {
	return &xudInitClient{cc}
}

func (c *xudInitClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error) {
	out := new(CreateNodeResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.XudInit/CreateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudInitClient) RestoreNode(ctx context.Context, in *RestoreNodeRequest, opts ...grpc.CallOption) (*RestoreNodeResponse, error) {
	out := new(RestoreNodeResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.XudInit/RestoreNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudInitClient) UnlockNode(ctx context.Context, in *UnlockNodeRequest, opts ...grpc.CallOption) (*UnlockNodeResponse, error) {
	out := new(UnlockNodeResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.XudInit/UnlockNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// XudInitServer is the server API for XudInit service.
type XudInitServer interface {
	// Creates an xud identity node key and underlying wallets. The node key and
	// wallets are derived from a single seed and encrypted using a single
	// password provided as a parameter to the call.
	// shell: xucli create
	CreateNode(context.Context, *CreateNodeRequest) (*CreateNodeResponse, error)
	// Restores an xud instance and underlying wallets from a seed.
	// shell: xucli restore [backup_directory]
	RestoreNode(context.Context, *RestoreNodeRequest) (*RestoreNodeResponse, error)
	// Unlocks and decrypts the xud node key and any underlying wallets.
	// shell: xucli unlock
	UnlockNode(context.Context, *UnlockNodeRequest) (*UnlockNodeResponse, error)
}

// UnimplementedXudInitServer can be embedded to have forward compatible implementations.
type UnimplementedXudInitServer struct {
}

func (*UnimplementedXudInitServer) CreateNode(context.Context, *CreateNodeRequest) (*CreateNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNode not implemented")
}
func (*UnimplementedXudInitServer) RestoreNode(context.Context, *RestoreNodeRequest) (*RestoreNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreNode not implemented")
}
func (*UnimplementedXudInitServer) UnlockNode(context.Context, *UnlockNodeRequest) (*UnlockNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockNode not implemented")
}

func RegisterXudInitServer(s *grpc.Server, srv XudInitServer) {
	s.RegisterService(&_XudInit_serviceDesc, srv)
}

func _XudInit_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/CreateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).CreateNode(ctx, req.(*CreateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XudInit_RestoreNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).RestoreNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/RestoreNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).RestoreNode(ctx, req.(*RestoreNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XudInit_UnlockNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).UnlockNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/UnlockNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).UnlockNode(ctx, req.(*UnlockNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _XudInit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.XudInit",
	HandlerType: (*XudInitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNode",
			Handler:    _XudInit_CreateNode_Handler,
		},
		{
			MethodName: "RestoreNode",
			Handler:    _XudInit_RestoreNode_Handler,
		},
		{
			MethodName: "UnlockNode",
			Handler:    _XudInit_UnlockNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "xudrpc.proto",
}

// XudClient is the client API for Xud service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type XudClient interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	// shell: xucli addcurrency <currency> <swap_client> [decimal_places] [token_address]
	AddCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	// shell: xucli addpair <base_currency> <quote_currency>
	AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	// shell: xucli ban <node_identifier>
	Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error)
	// Closes any existing payment channels with a peer for the specified currency.
	// shell: xucli closechannel <currency> [node_identifier ] [--force]
	CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (*CloseChannelResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	// shell: xucli connect <node_uri>
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// Gets an address to deposit a given currency into the xud wallets.
	// shell: xucli walletdeposit <currency>
	WalletDeposit(ctx context.Context, in *DepositRequest, opts ...grpc.CallOption) (*DepositResponse, error)
	// Discover nodes from a specific peer and apply new connections
	DiscoverNodes(ctx context.Context, in *DiscoverNodesRequest, opts ...grpc.CallOption) (*DiscoverNodesResponse, error)
	// Gets the total balance available across all payment channels and wallets for one or all currencies.
	// shell: xucli getbalance [currency]
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	// Gets general information about this node.
	// shell: xucli getinfo
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// Gets general information about a node.
	// shell: xucli getnodeinfo <node_identifier>
	GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	// shell: xucli listorders [pair_id] [include_own_orders] [limit]
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	// shell: xucli listcurrencies
	ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	// shell: xucli listpairs
	ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	// shell: xucli listpeers
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	// Opens a payment channel to a peer for the specified amount and currency.
	// shell: xucli openchannel <currency> <amount> [node_identifier] [push_amount]
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error)
	// The synchronous, non-streaming version of PlaceOrder.
	// shell: xucli buy <quantity> <pair_id> <price> [order_id] [stream]
	// shell: xucli sell <quantity> <pair_id> <price> [order_id] [stream]
	PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Executes a swap on a maker peer order.
	ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*SwapSuccess, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	// shell: xucli removecurrency <currency>
	RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	// shell: xucli removeorder <order_id> [quantity]
	RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	// shell: xucli removepair <pair_id>
	RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error)
	// Begin gracefully shutting down xud.
	// shell: xucli shutdown
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Subscribes to orders being added to and removed from the order book. This call allows the client
	// to maintain an up-to-date view of the order book. For example, an exchange that wants to show
	// its users a real time view of the orders available to them would subscribe to this streaming
	// call to be alerted as new orders are added and expired orders are removed.
	SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeOrdersClient, error)
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error)
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error)
	// Subscribes to accepted swaps. This stream emits a message when the local xud node
	// accepts a swap request from a peer, but before the swap has actually succeeded.
	SubscribeSwapsAccepted(ctx context.Context, in *SubscribeSwapsAcceptedRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsAcceptedClient, error)
	// Gets a list of completed trades.
	// shell: xucli tradehistory [limit]
	TradeHistory(ctx context.Context, in *TradeHistoryRequest, opts ...grpc.CallOption) (*TradeHistoryResponse, error)
	// Gets the trading limits for one or all currencies.
	// shell: xucli tradinglimits [currency]
	TradingLimits(ctx context.Context, in *TradingLimitsRequest, opts ...grpc.CallOption) (*TradingLimitsResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	// shell: xucli unban <node_identifier> [reconnect]
	Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error)
	// Withdraws a given currency from the xud wallets to a specified address.
	// shell: xucli withdraw [amount] [currency] <destination> [fee]
	WalletWithdraw(ctx context.Context, in *WithdrawRequest, opts ...grpc.CallOption) (*WithdrawResponse, error)
}

type xudClient struct {
	cc grpc.ClientConnInterface
}

func NewXudClient(cc grpc.ClientConnInterface) XudClient {
	return &xudClient{cc}
}

func (c *xudClient) AddCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*AddCurrencyResponse, error) {
	out := new(AddCurrencyResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/AddCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error) {
	out := new(AddPairResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/AddPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error) {
	out := new(BanResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Ban", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (*CloseChannelResponse, error) {
	out := new(CloseChannelResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/CloseChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) WalletDeposit(ctx context.Context, in *DepositRequest, opts ...grpc.CallOption) (*DepositResponse, error) {
	out := new(DepositResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/WalletDeposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) DiscoverNodes(ctx context.Context, in *DiscoverNodesRequest, opts ...grpc.CallOption) (*DiscoverNodesResponse, error) {
	out := new(DiscoverNodesResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/DiscoverNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/GetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error) {
	out := new(GetNodeInfoResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error) {
	out := new(ListCurrenciesResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListCurrencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error) {
	out := new(ListPairsResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListPairs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error) {
	out := new(OpenChannelResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/OpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[0], "/xudrpc.Xud/PlaceOrder", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudPlaceOrderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_PlaceOrderClient interface {
	Recv() (*PlaceOrderEvent, error)
	grpc.ClientStream
}

type xudPlaceOrderClient struct {
	grpc.ClientStream
}

func (x *xudPlaceOrderClient) Recv() (*PlaceOrderEvent, error) {
	m := new(PlaceOrderEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/PlaceOrderSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*SwapSuccess, error) {
	out := new(SwapSuccess)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ExecuteSwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error) {
	out := new(RemoveCurrencyResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/RemoveCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error) {
	out := new(RemoveOrderResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/RemoveOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error) {
	out := new(RemovePairResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/RemovePair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[1], "/xudrpc.Xud/SubscribeOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeOrdersClient interface {
	Recv() (*OrderUpdate, error)
	grpc.ClientStream
}

type xudSubscribeOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeOrdersClient) Recv() (*OrderUpdate, error) {
	m := new(OrderUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[2], "/xudrpc.Xud/SubscribeSwapFailures", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapFailuresClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapFailuresClient interface {
	Recv() (*SwapFailure, error)
	grpc.ClientStream
}

type xudSubscribeSwapFailuresClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapFailuresClient) Recv() (*SwapFailure, error) {
	m := new(SwapFailure)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[3], "/xudrpc.Xud/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapsClient interface {
	Recv() (*SwapSuccess, error)
	grpc.ClientStream
}

type xudSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapsClient) Recv() (*SwapSuccess, error) {
	m := new(SwapSuccess)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwapsAccepted(ctx context.Context, in *SubscribeSwapsAcceptedRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsAcceptedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[4], "/xudrpc.Xud/SubscribeSwapsAccepted", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapsAcceptedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapsAcceptedClient interface {
	Recv() (*SwapAccepted, error)
	grpc.ClientStream
}

type xudSubscribeSwapsAcceptedClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapsAcceptedClient) Recv() (*SwapAccepted, error) {
	m := new(SwapAccepted)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) TradeHistory(ctx context.Context, in *TradeHistoryRequest, opts ...grpc.CallOption) (*TradeHistoryResponse, error) {
	out := new(TradeHistoryResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/TradeHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) TradingLimits(ctx context.Context, in *TradingLimitsRequest, opts ...grpc.CallOption) (*TradingLimitsResponse, error) {
	out := new(TradingLimitsResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/TradingLimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error) {
	out := new(UnbanResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Unban", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) WalletWithdraw(ctx context.Context, in *WithdrawRequest, opts ...grpc.CallOption) (*WithdrawResponse, error) {
	out := new(WithdrawResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/WalletWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// XudServer is the server API for Xud service.
type XudServer interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	// shell: xucli addcurrency <currency> <swap_client> [decimal_places] [token_address]
	AddCurrency(context.Context, *Currency) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	// shell: xucli addpair <base_currency> <quote_currency>
	AddPair(context.Context, *AddPairRequest) (*AddPairResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	// shell: xucli ban <node_identifier>
	Ban(context.Context, *BanRequest) (*BanResponse, error)
	// Closes any existing payment channels with a peer for the specified currency.
	// shell: xucli closechannel <currency> [node_identifier ] [--force]
	CloseChannel(context.Context, *CloseChannelRequest) (*CloseChannelResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	// shell: xucli connect <node_uri>
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// Gets an address to deposit a given currency into the xud wallets.
	// shell: xucli walletdeposit <currency>
	WalletDeposit(context.Context, *DepositRequest) (*DepositResponse, error)
	// Discover nodes from a specific peer and apply new connections
	DiscoverNodes(context.Context, *DiscoverNodesRequest) (*DiscoverNodesResponse, error)
	// Gets the total balance available across all payment channels and wallets for one or all currencies.
	// shell: xucli getbalance [currency]
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	// Gets general information about this node.
	// shell: xucli getinfo
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// Gets general information about a node.
	// shell: xucli getnodeinfo <node_identifier>
	GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	// shell: xucli listorders [pair_id] [include_own_orders] [limit]
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	// shell: xucli listcurrencies
	ListCurrencies(context.Context, *ListCurrenciesRequest) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	// shell: xucli listpairs
	ListPairs(context.Context, *ListPairsRequest) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	// shell: xucli listpeers
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	// Opens a payment channel to a peer for the specified amount and currency.
	// shell: xucli openchannel <currency> <amount> [node_identifier] [push_amount]
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(*PlaceOrderRequest, Xud_PlaceOrderServer) error
	// The synchronous, non-streaming version of PlaceOrder.
	// shell: xucli buy <quantity> <pair_id> <price> [order_id] [stream]
	// shell: xucli sell <quantity> <pair_id> <price> [order_id] [stream]
	PlaceOrderSync(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Executes a swap on a maker peer order.
	ExecuteSwap(context.Context, *ExecuteSwapRequest) (*SwapSuccess, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	// shell: xucli removecurrency <currency>
	RemoveCurrency(context.Context, *RemoveCurrencyRequest) (*RemoveCurrencyResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	// shell: xucli removeorder <order_id> [quantity]
	RemoveOrder(context.Context, *RemoveOrderRequest) (*RemoveOrderResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	// shell: xucli removepair <pair_id>
	RemovePair(context.Context, *RemovePairRequest) (*RemovePairResponse, error)
	// Begin gracefully shutting down xud.
	// shell: xucli shutdown
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Subscribes to orders being added to and removed from the order book. This call allows the client
	// to maintain an up-to-date view of the order book. For example, an exchange that wants to show
	// its users a real time view of the orders available to them would subscribe to this streaming
	// call to be alerted as new orders are added and expired orders are removed.
	SubscribeOrders(*SubscribeOrdersRequest, Xud_SubscribeOrdersServer) error
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(*SubscribeSwapsRequest, Xud_SubscribeSwapFailuresServer) error
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(*SubscribeSwapsRequest, Xud_SubscribeSwapsServer) error
	// Subscribes to accepted swaps. This stream emits a message when the local xud node
	// accepts a swap request from a peer, but before the swap has actually succeeded.
	SubscribeSwapsAccepted(*SubscribeSwapsAcceptedRequest, Xud_SubscribeSwapsAcceptedServer) error
	// Gets a list of completed trades.
	// shell: xucli tradehistory [limit]
	TradeHistory(context.Context, *TradeHistoryRequest) (*TradeHistoryResponse, error)
	// Gets the trading limits for one or all currencies.
	// shell: xucli tradinglimits [currency]
	TradingLimits(context.Context, *TradingLimitsRequest) (*TradingLimitsResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	// shell: xucli unban <node_identifier> [reconnect]
	Unban(context.Context, *UnbanRequest) (*UnbanResponse, error)
	// Withdraws a given currency from the xud wallets to a specified address.
	// shell: xucli withdraw [amount] [currency] <destination> [fee]
	WalletWithdraw(context.Context, *WithdrawRequest) (*WithdrawResponse, error)
}

// UnimplementedXudServer can be embedded to have forward compatible implementations.
type UnimplementedXudServer struct {
}

func (*UnimplementedXudServer) AddCurrency(context.Context, *Currency) (*AddCurrencyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCurrency not implemented")
}
func (*UnimplementedXudServer) AddPair(context.Context, *AddPairRequest) (*AddPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPair not implemented")
}
func (*UnimplementedXudServer) Ban(context.Context, *BanRequest) (*BanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ban not implemented")
}
func (*UnimplementedXudServer) CloseChannel(context.Context, *CloseChannelRequest) (*CloseChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseChannel not implemented")
}
func (*UnimplementedXudServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (*UnimplementedXudServer) WalletDeposit(context.Context, *DepositRequest) (*DepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletDeposit not implemented")
}
func (*UnimplementedXudServer) DiscoverNodes(context.Context, *DiscoverNodesRequest) (*DiscoverNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscoverNodes not implemented")
}
func (*UnimplementedXudServer) GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (*UnimplementedXudServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfo not implemented")
}
func (*UnimplementedXudServer) GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (*UnimplementedXudServer) ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}
func (*UnimplementedXudServer) ListCurrencies(context.Context, *ListCurrenciesRequest) (*ListCurrenciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCurrencies not implemented")
}
func (*UnimplementedXudServer) ListPairs(context.Context, *ListPairsRequest) (*ListPairsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPairs not implemented")
}
func (*UnimplementedXudServer) ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPeers not implemented")
}
func (*UnimplementedXudServer) OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenChannel not implemented")
}
func (*UnimplementedXudServer) PlaceOrder(*PlaceOrderRequest, Xud_PlaceOrderServer) error {
	return status.Errorf(codes.Unimplemented, "method PlaceOrder not implemented")
}
func (*UnimplementedXudServer) PlaceOrderSync(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceOrderSync not implemented")
}
func (*UnimplementedXudServer) ExecuteSwap(context.Context, *ExecuteSwapRequest) (*SwapSuccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSwap not implemented")
}
func (*UnimplementedXudServer) RemoveCurrency(context.Context, *RemoveCurrencyRequest) (*RemoveCurrencyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCurrency not implemented")
}
func (*UnimplementedXudServer) RemoveOrder(context.Context, *RemoveOrderRequest) (*RemoveOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveOrder not implemented")
}
func (*UnimplementedXudServer) RemovePair(context.Context, *RemovePairRequest) (*RemovePairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePair not implemented")
}
func (*UnimplementedXudServer) Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (*UnimplementedXudServer) SubscribeOrders(*SubscribeOrdersRequest, Xud_SubscribeOrdersServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeOrders not implemented")
}
func (*UnimplementedXudServer) SubscribeSwapFailures(*SubscribeSwapsRequest, Xud_SubscribeSwapFailuresServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeSwapFailures not implemented")
}
func (*UnimplementedXudServer) SubscribeSwaps(*SubscribeSwapsRequest, Xud_SubscribeSwapsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeSwaps not implemented")
}
func (*UnimplementedXudServer) SubscribeSwapsAccepted(*SubscribeSwapsAcceptedRequest, Xud_SubscribeSwapsAcceptedServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeSwapsAccepted not implemented")
}
func (*UnimplementedXudServer) TradeHistory(context.Context, *TradeHistoryRequest) (*TradeHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradeHistory not implemented")
}
func (*UnimplementedXudServer) TradingLimits(context.Context, *TradingLimitsRequest) (*TradingLimitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradingLimits not implemented")
}
func (*UnimplementedXudServer) Unban(context.Context, *UnbanRequest) (*UnbanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unban not implemented")
}
func (*UnimplementedXudServer) WalletWithdraw(context.Context, *WithdrawRequest) (*WithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletWithdraw not implemented")
}

func RegisterXudServer(s *grpc.Server, srv XudServer) {
	s.RegisterService(&_Xud_serviceDesc, srv)
}

func _Xud_AddCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Currency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddCurrency(ctx, req.(*Currency))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_AddPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddPair(ctx, req.(*AddPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Ban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Ban(ctx, req.(*BanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_CloseChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).CloseChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/CloseChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).CloseChannel(ctx, req.(*CloseChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_WalletDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).WalletDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/WalletDeposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).WalletDeposit(ctx, req.(*DepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_DiscoverNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).DiscoverNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/DiscoverNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).DiscoverNodes(ctx, req.(*DiscoverNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetNodeInfo(ctx, req.(*GetNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCurrenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListCurrencies(ctx, req.(*ListCurrenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPairs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPairs(ctx, req.(*ListPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_PlaceOrder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlaceOrderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).PlaceOrder(m, &xudPlaceOrderServer{stream})
}

type Xud_PlaceOrderServer interface {
	Send(*PlaceOrderEvent) error
	grpc.ServerStream
}

type xudPlaceOrderServer struct {
	grpc.ServerStream
}

func (x *xudPlaceOrderServer) Send(m *PlaceOrderEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_PlaceOrderSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).PlaceOrderSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/PlaceOrderSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).PlaceOrderSync(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ExecuteSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ExecuteSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ExecuteSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ExecuteSwap(ctx, req.(*ExecuteSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveCurrency(ctx, req.(*RemoveCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveOrder(ctx, req.(*RemoveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemovePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemovePair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemovePair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemovePair(ctx, req.(*RemovePairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_SubscribeOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeOrders(m, &xudSubscribeOrdersServer{stream})
}

type Xud_SubscribeOrdersServer interface {
	Send(*OrderUpdate) error
	grpc.ServerStream
}

type xudSubscribeOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeOrdersServer) Send(m *OrderUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwapFailures_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwapFailures(m, &xudSubscribeSwapFailuresServer{stream})
}

type Xud_SubscribeSwapFailuresServer interface {
	Send(*SwapFailure) error
	grpc.ServerStream
}

type xudSubscribeSwapFailuresServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapFailuresServer) Send(m *SwapFailure) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwaps(m, &xudSubscribeSwapsServer{stream})
}

type Xud_SubscribeSwapsServer interface {
	Send(*SwapSuccess) error
	grpc.ServerStream
}

type xudSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapsServer) Send(m *SwapSuccess) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwapsAccepted_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsAcceptedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwapsAccepted(m, &xudSubscribeSwapsAcceptedServer{stream})
}

type Xud_SubscribeSwapsAcceptedServer interface {
	Send(*SwapAccepted) error
	grpc.ServerStream
}

type xudSubscribeSwapsAcceptedServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapsAcceptedServer) Send(m *SwapAccepted) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_TradeHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).TradeHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/TradeHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).TradeHistory(ctx, req.(*TradeHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_TradingLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradingLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).TradingLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/TradingLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).TradingLimits(ctx, req.(*TradingLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Unban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Unban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Unban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Unban(ctx, req.(*UnbanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_WalletWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).WalletWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/WalletWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).WalletWithdraw(ctx, req.(*WithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Xud_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.Xud",
	HandlerType: (*XudServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCurrency",
			Handler:    _Xud_AddCurrency_Handler,
		},
		{
			MethodName: "AddPair",
			Handler:    _Xud_AddPair_Handler,
		},
		{
			MethodName: "Ban",
			Handler:    _Xud_Ban_Handler,
		},
		{
			MethodName: "CloseChannel",
			Handler:    _Xud_CloseChannel_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Xud_Connect_Handler,
		},
		{
			MethodName: "WalletDeposit",
			Handler:    _Xud_WalletDeposit_Handler,
		},
		{
			MethodName: "DiscoverNodes",
			Handler:    _Xud_DiscoverNodes_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _Xud_GetBalance_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Xud_GetInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Xud_GetNodeInfo_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Xud_ListOrders_Handler,
		},
		{
			MethodName: "ListCurrencies",
			Handler:    _Xud_ListCurrencies_Handler,
		},
		{
			MethodName: "ListPairs",
			Handler:    _Xud_ListPairs_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Xud_ListPeers_Handler,
		},
		{
			MethodName: "OpenChannel",
			Handler:    _Xud_OpenChannel_Handler,
		},
		{
			MethodName: "PlaceOrderSync",
			Handler:    _Xud_PlaceOrderSync_Handler,
		},
		{
			MethodName: "ExecuteSwap",
			Handler:    _Xud_ExecuteSwap_Handler,
		},
		{
			MethodName: "RemoveCurrency",
			Handler:    _Xud_RemoveCurrency_Handler,
		},
		{
			MethodName: "RemoveOrder",
			Handler:    _Xud_RemoveOrder_Handler,
		},
		{
			MethodName: "RemovePair",
			Handler:    _Xud_RemovePair_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Xud_Shutdown_Handler,
		},
		{
			MethodName: "TradeHistory",
			Handler:    _Xud_TradeHistory_Handler,
		},
		{
			MethodName: "TradingLimits",
			Handler:    _Xud_TradingLimits_Handler,
		},
		{
			MethodName: "Unban",
			Handler:    _Xud_Unban_Handler,
		},
		{
			MethodName: "WalletWithdraw",
			Handler:    _Xud_WalletWithdraw_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PlaceOrder",
			Handler:       _Xud_PlaceOrder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeOrders",
			Handler:       _Xud_SubscribeOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwapFailures",
			Handler:       _Xud_SubscribeSwapFailures_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Xud_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwapsAccepted",
			Handler:       _Xud_SubscribeSwapsAccepted_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "xudrpc.proto",
}
